<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Dream</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020505; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        /* æ‘„åƒå¤´é¢„è§ˆ (è°ƒè¯•ç”¨ï¼Œå¯éšè—) */
        #video-preview {
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; 
            border: 2px solid #D4AF37; border-radius: 8px; transform: scaleX(-1); opacity: 0.7;
        }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #status-bar {
            color: #D4AF37; text-shadow: 0 0 10px #D4AF37; font-size: 14px; background: rgba(0,0,0,0.5);
            padding: 10px; border-radius: 4px; pointer-events: auto; max-width: 300px;
        }
        
        /* ä¸Šä¼ æŒ‰é’® */
        #upload-btn {
            pointer-events: auto; cursor: pointer; background: rgba(212, 175, 55, 0.2); border: 1px solid #D4AF37;
            color: #D4AF37; padding: 10px 20px; border-radius: 20px; transition: 0.3s; text-transform: uppercase;
            font-weight: bold; margin-top: 10px; display: inline-block; text-align: center;
        }
        #upload-btn:hover { background: #D4AF37; color: #000; box-shadow: 0 0 20px #D4AF37; }
        
        /* åŠ è½½é®ç½© */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100;
            display: flex; justify-content: center; align-items: center; color: #D4AF37; flex-direction: column;
            transition: opacity 1s;
        }
        .spinner {
            width: 50px; height: 50px; border: 3px solid transparent; border-top-color: #D4AF37; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* æ‰‹åŠ¿æç¤º */
        .guide { font-size: 12px; color: #aaa; margin-top: 5px; }
    </style>
    
    <!-- å¼•å…¥åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <div>INITIALIZING CHRISTMAS MAGIC...</div>
    <div style="font-size: 12px; margin-top:10px; color:#666;">Please allow camera access</div>
</div>

<div id="ui-layer">
    <div id="status-bar">
        <div><strong>CURRENT STATE:</strong> <span id="state-text">TREE (MERGED)</span></div>
        <div class="guide">ğŸ‘Š FIST: Merge Tree | ğŸ– OPEN: Scatter | ğŸ‘Œ PINCH: Grab Photo</div>
        <label id="upload-btn">
            Upload Memories (Photos)
            <input type="file" id="file-input" multiple accept="image/*" style="display:none;">
        </label>
    </div>
</div>

<video id="video-preview" playsinline></video>
<div id="canvas-container"></div>

<script>
/**
 * æ ¸å¿ƒé…ç½®ä¸çŠ¶æ€ç®¡ç†
 */
const CONFIG = {
    particleCount: 45000,
    treeHeight: 60,
    treeRadius: 25,
    colors: [0xD4AF37, 0xC41E3A, 0x2E8B57], // é‡‘, çº¢, ç»¿
    bloom: { strength: 1.8, radius: 0.6, threshold: 0.1 }
};

const STATE = {
    current: 'TREE', // 'TREE', 'SCATTER', 'FOCUS'
    handDetected: false,
    focusedPhoto: null,
    rotationSpeed: 0,
    targetRotationY: 0
};

// å…¨å±€å˜é‡
let scene, camera, renderer, composer;
let treeSystem, snowSystem;
let photos = []; // å­˜å‚¨ç…§ç‰‡Meshå¯¹è±¡
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2(); // ç”¨äºæ‰‹éƒ¨æ˜ å°„
let handLandmarks = null;

/**
 * 1. Three.js åˆå§‹åŒ–ä¸åœºæ™¯æ„å»º
 */
function initThree() {
    const container = document.getElementById('canvas-container');
    
    // åœºæ™¯
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020505, 0.015);

    // ç›¸æœº
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 20, 80);

    // æ¸²æŸ“å™¨
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ReinhardToneMapping;
    container.appendChild(renderer.domElement);

    // åå¤„ç† (Bloom)
    const renderScene = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        CONFIG.bloom.strength,
        CONFIG.bloom.radius,
        CONFIG.bloom.threshold
    );
    
    composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xD4AF37, 1, 100);
    pointLight.position.set(0, 30, 20);
    scene.add(pointLight);

    // åˆ›å»ºå…ƒç´ 
    createTreeParticles();
    createSnow();
    
    // çª—å£è°ƒæ•´
    window.addEventListener('resize', onWindowResize, false);
    
    // éšè—åŠ è½½é¡µ
    setTimeout(() => {
        document.getElementById('loader').style.opacity = '0';
        setTimeout(() => document.getElementById('loader').style.display = 'none', 1000);
    }, 2000);
}

/**
 * 2. ç²’å­ç³»ç»Ÿ (åœ£è¯æ ‘ä¸»ä½“)
 */
function createTreeParticles() {
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    const sizes = [];
    const originalPos = []; // å­˜å‚¨æ ‘å½¢æ€ä½ç½®
    const scatteredPos = []; // å­˜å‚¨æ•£å¼€å½¢æ€ä½ç½®

    const colorObj = new THREE.Color();

    for (let i = 0; i < CONFIG.particleCount; i++) {
        // --- æ ‘å½¢æ€ç®—æ³• (èºæ—‹åœ†é”¥) ---
        const y = Math.random() * CONFIG.treeHeight; 
        const radiusAtY = (CONFIG.treeHeight - y) / CONFIG.treeHeight * CONFIG.treeRadius;
        const angle = y * 1.5 + Math.random() * Math.PI * 2; // èºæ—‹å› å­
        const randomOffset = Math.random() * 2; // è¡¨é¢åšåº¦

        const tx = Math.cos(angle) * (radiusAtY + randomOffset);
        const tz = Math.sin(angle) * (radiusAtY + randomOffset);
        const ty = y - CONFIG.treeHeight / 2;

        positions.push(tx, ty, tz);
        originalPos.push(tx, ty, tz);

        // --- æ•£å¼€å½¢æ€ç®—æ³• (çƒå½¢éšæœº) ---
        const range = 100;
        const sx = (Math.random() - 0.5) * range;
        const sy = (Math.random() - 0.5) * range;
        const sz = (Math.random() - 0.5) * range;
        scatteredPos.push(sx, sy, sz);

        // --- é¢œè‰² ---
        // ä¸»è¦æ˜¯ç»¿è‰²ï¼Œéšæœºç‚¹ç¼€é‡‘è‰²å’Œçº¢è‰²
        const rand = Math.random();
        let hex;
        if (rand > 0.95) hex = CONFIG.colors[0]; // é‡‘
        else if (rand > 0.9) hex = CONFIG.colors[1]; // çº¢
        else hex = CONFIG.colors[2]; // ç»¿
        
        colorObj.setHex(hex);
        colors.push(colorObj.r, colorObj.g, colorObj.b);

        // --- å¤§å° ---
        sizes.push(Math.random() * 0.5 + 0.1);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
    geometry.setAttribute('aScatter', new THREE.Float32BufferAttribute(scatteredPos, 3));
    geometry.setAttribute('aOriginal', new THREE.Float32BufferAttribute(originalPos, 3));

    // è‡ªå®šä¹‰ç€è‰²å™¨å®ç°ç²’å­é—ªçƒ
    const material = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            pointTexture: { value: new THREE.TextureLoader().load('https://assets.codepen.io/127738/dotTexture.png') },
            mixVal: { value: 0.0 } // 0 = Tree, 1 = Scatter
        },
        vertexShader: `
            attribute float size;
            attribute vec3 color;
            attribute vec3 aScatter;
            attribute vec3 aOriginal;
            varying vec3 vColor;
            uniform float time;
            uniform float mixVal;
            void main() {
                vColor = color;
                
                // çŠ¶æ€æ··åˆæ’å€¼
                vec3 pos = mix(aOriginal, aScatter, mixVal);
                
                // åŠ¨æ€å‘¼å¸æ•ˆæœ
                float pulse = sin(time * 3.0 + pos.y * 0.1) * 0.2 + 1.0;
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = size * pulse * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
                gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                if (gl_FragColor.a < 0.5) discard;
            }
        `,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        transparent: true
    });

    treeSystem = new THREE.Points(geometry, material);
    scene.add(treeSystem);
}

/**
 * 3. é£˜é›ªæ•ˆæœ
 */
function createSnow() {
    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    for (let i = 0; i < 2000; i++) {
        vertices.push(
            Math.random() * 200 - 100,
            Math.random() * 200 - 100,
            Math.random() * 200 - 100
        );
    }
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    
    const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.5,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });
    
    snowSystem = new THREE.Points(geometry, material);
    scene.add(snowSystem);
}

/**
 * 4. ç…§ç‰‡ç”»å»Šç³»ç»Ÿ
 */
document.getElementById('file-input').addEventListener('change', handleImageUpload);

function handleImageUpload(event) {
    const files = event.target.files;
    if(!files.length) return;

    // é™åˆ¶æ•°é‡ä»¥å…å¡é¡¿
    for (let i = 0; i < Math.min(files.length, 20); i++) {
        const reader = new FileReader();
        reader.onload = function(e) {
            createPolaroid(e.target.result);
        };
        reader.readAsDataURL(files[i]);
    }
}

function createPolaroid(imgUrl) {
    const loader = new THREE.TextureLoader();
    loader.load(imgUrl, (texture) => {
        // æ‹ç«‹å¾—å‡ ä½•ä½“ (Group)
        const group = new THREE.Group();
        
        // ç™½æ¡†
        const frameGeo = new THREE.PlaneGeometry(6, 7);
        const frameMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        
        // ç…§ç‰‡é¢
        const photoGeo = new THREE.PlaneGeometry(5, 5);
        const photoMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
        const photo = new THREE.Mesh(photoGeo, photoMat);
        photo.position.z = 0.05; // ç¨å¾®çªèµ·
        photo.position.y = 0.5;
        
        group.add(frame);
        group.add(photo);

        // éšæœºåˆå§‹ä½ç½® (æ ‘ä¸Š)
        const y = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
        const radius = (CONFIG.treeHeight/2 - y) / CONFIG.treeHeight * CONFIG.treeRadius * 1.2; // ç¨å¾®åœ¨æ ‘å¤–
        const angle = Math.random() * Math.PI * 2;
        
        // ä¿å­˜æ•°æ®ä»¥ä¾¿åŠ¨ç”»
        group.userData = {
            treePos: new THREE.Vector3(Math.cos(angle)*radius, y, Math.sin(angle)*radius),
            treeRot: new THREE.Euler(0, -angle, 0), // é¢å‘å¤–
            scatterPos: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80),
            scatterRot: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0),
            id: Math.random().toString(36).substr(2, 9)
        };

        // åˆå§‹è®¾ä¸º Tree çŠ¶æ€
        group.position.copy(group.userData.treePos);
        group.rotation.copy(group.userData.treeRot);
        // é¢å‘ä¸­å¿ƒä¿®æ­£
        group.lookAt(0, y, 0);

        scene.add(group);
        photos.push(group);
        
        // è¿›åœºåŠ¨ç”»
        gsap.from(group.scale, { x: 0, y: 0, z: 0, duration: 1, ease: "elastic.out(1, 0.3)" });
    });
}

/**
 * 5. MediaPipe æ‰‹åŠ¿è¯†åˆ«ä¸é€»è¾‘
 */
function setupMediaPipe() {
    const video = document.getElementById('video-preview');
    
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.5
    });
    
    hands.onResults(onHandsResults);
    
    const cameraUtils = new Camera(video, {
        onFrame: async () => {
            await hands.send({image: video});
        },
        width: 320,
        height: 240
    });
    
    cameraUtils.start();
}

function onHandsResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        handLandmarks = results.multiHandLandmarks[0];
        STATE.handDetected = true;
        
        // 1. è¯†åˆ«æ‰‹åŠ¿
        const gesture = detectGesture(handLandmarks);
        updateStateByGesture(gesture);
        
        // 2. æ›´æ–°äº¤äº’æŒ‡é’ˆ (ç”¨äºæŠ“å–)
        updateHandCursor(handLandmarks);

        // 3. æ—‹è½¬æ§åˆ¶ (åœ¨ SCATTER çŠ¶æ€ä¸‹)
        if (STATE.current === 'SCATTER' && gesture !== 'PINCH') {
            handleRotation(handLandmarks);
        }

    } else {
        STATE.handDetected = false;
        // æ— æ‰‹åŠ¿æ—¶ç¨å¾®è‡ªåŠ¨æ—‹è½¬
        STATE.targetRotationY += 0.002;
    }
}

// ç®€å•æ‰‹åŠ¿åˆ¤å®šç®—æ³•
function detectGesture(landmarks) {
    const thumbTip = landmarks[4];
    const indexTip = landmarks[8];
    const middleTip = landmarks[12];
    const ringTip = landmarks[16];
    const pinkyTip = landmarks[20];
    const wrist = landmarks[0];

    // è®¡ç®—æŒ‡å°–åˆ°æ‰‹æŒåŸºéƒ¨è·ç¦» (ç®€å•çš„å¼€åˆåˆ¤å®š)
    const fingersOpen = [indexTip, middleTip, ringTip, pinkyTip].every(tip => {
        return distance(tip, wrist) > 0.3; // é˜ˆå€¼éœ€è°ƒè¯•
    });

    // æåˆåˆ¤å®š (é£ŸæŒ‡ä¸æ‹‡æŒ‡è·ç¦»)
    const pinchDist = distance(thumbTip, indexTip);
    
    // æ¡æ‹³åˆ¤å®š (æŒ‡å°–é è¿‘æ‰‹æŒ)
    const isFist = [indexTip, middleTip, ringTip, pinkyTip].every(tip => {
        return distance(tip, wrist) < 0.25;
    });

    if (pinchDist < 0.05) return 'PINCH';
    if (isFist) return 'FIST';
    if (fingersOpen) return 'OPEN';
    
    return 'UNKNOWN';
}

function distance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

function updateStateByGesture(gesture) {
    const statusText = document.getElementById('state-text');
    
    if (gesture === 'FIST' && STATE.current !== 'TREE') {
        transitionToTree();
        statusText.innerText = "TREE (MERGED)";
    } 
    else if (gesture === 'OPEN' && STATE.current !== 'SCATTER') {
        transitionToScatter();
        statusText.innerText = "SCATTER (FLOATING)";
    }
    else if (gesture === 'PINCH') {
        // åªæœ‰åœ¨æ•£å¼€çŠ¶æ€ä¸‹æ‰èƒ½æŠ“å–ï¼Œæˆ–è€…å·²ç»åœ¨FOCUSçŠ¶æ€ä¸‹ä¿æŒ
        if (STATE.current === 'SCATTER') {
            tryGrabPhoto();
        }
    }
}

/**
 * 6. çŠ¶æ€è½¬æ¢ä¸åŠ¨ç”»é€»è¾‘ (GSAP)
 */

function transitionToTree() {
    STATE.current = 'TREE';
    
    // é‡Šæ”¾èšç„¦çš„ç…§ç‰‡
    if(STATE.focusedPhoto) {
        gsap.to(STATE.focusedPhoto.scale, {x:1, y:1, z:1, duration: 0.5});
        STATE.focusedPhoto = null;
    }

    // ç²’å­èšåˆ
    gsap.to(treeSystem.material.uniforms.mixVal, { value: 0.0, duration: 2, ease: "power2.inOut" });

    // ç…§ç‰‡å½’ä½
    photos.forEach(p => {
        gsap.to(p.position, { 
            x: p.userData.treePos.x, 
            y: p.userData.treePos.y, 
            z: p.userData.treePos.z, 
            duration: 1.5, ease: "power2.inOut" 
        });
        gsap.to(p.rotation, {
            x: p.userData.treeRot.x,
            y: p.userData.treeRot.y,
            z: p.userData.treeRot.z,
            duration: 1.5
        });
        // æ¢å¤é¢å‘ä¸­å¿ƒ
        p.lookAt(0, p.position.y, 0); 
    });

    // ç›¸æœºå¤ä½
    gsap.to(camera.position, { x: 0, y: 20, z: 80, duration: 2 });
}

function transitionToScatter() {
    STATE.current = 'SCATTER';

    // é‡Šæ”¾èšç„¦çš„ç…§ç‰‡
    if(STATE.focusedPhoto) {
        gsap.to(STATE.focusedPhoto.scale, {x:1, y:1, z:1, duration: 0.5});
        STATE.focusedPhoto = null;
    }

    // ç²’å­æ•£å¼€
    gsap.to(treeSystem.material.uniforms.mixVal, { value: 1.0, duration: 2, ease: "power2.out" });

    // ç…§ç‰‡æ¼‚æµ®
    photos.forEach(p => {
        gsap.to(p.position, { 
            x: p.userData.scatterPos.x, 
            y: p.userData.scatterPos.y, 
            z: p.userData.scatterPos.z, 
            duration: 2, ease: "power2.out" 
        });
        gsap.to(p.rotation, {
            x: p.userData.scatterRot.x,
            y: p.userData.scatterRot.y,
            z: p.userData.scatterRot.z,
            duration: 2
        });
    });
}

function tryGrabPhoto() {
    // å°„çº¿æ£€æµ‹
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(photos, true); // recursive for groups

    if (intersects.length > 0) {
        const hitGroup = intersects[0].object.parent; // æˆ‘ä»¬çš„ç…§ç‰‡åœ¨Groupé‡Œ
        if (hitGroup && hitGroup !== STATE.focusedPhoto) {
            transitionToFocus(hitGroup);
        }
    }
}

function transitionToFocus(photoGroup) {
    STATE.current = 'FOCUS';
    STATE.focusedPhoto = photoGroup;
    document.getElementById('state-text').innerText = "FOCUS (MEMORY)";

    // è®¡ç®—ç›¸æœºå‰æ–¹çš„ä½ç½®
    const targetPos = new THREE.Vector3(0, 0, -20); // ç›¸æœºå‰æ–¹20å•ä½
    targetPos.applyMatrix4(camera.matrixWorld);

    gsap.to(photoGroup.position, {
        x: targetPos.x,
        y: targetPos.y,
        z: targetPos.z,
        duration: 1,
        ease: "power3.out",
        onUpdate: () => {
            photoGroup.lookAt(camera.position);
        }
    });

    // æ”¾å¤§
    gsap.to(photoGroup.scale, { x: 3, y: 3, z: 3, duration: 1 });
}

/**
 * è¾…åŠ©ï¼šæ‰‹éƒ¨æ˜ å°„åˆ°3Dç©ºé—´
 */
function updateHandCursor(landmarks) {
    // ä½¿ç”¨é£ŸæŒ‡å°– (Index Tip: 8)
    const ndcX = (landmarks[8].x * 2 - 1) * -1; // MediaPipe xæ˜¯é•œåƒçš„
    const ndcY = (landmarks[8].y * 2 - 1) * -1; // Yè½´åè½¬
    mouse.set(ndcX, ndcY);
}

function handleRotation(landmarks) {
    // ä½¿ç”¨æ‰‹æŒä¸­å¿ƒxåæ ‡æ§åˆ¶æ—‹è½¬
    const x = landmarks[9].x; // 0-1
    // æ˜ å°„ï¼šæ‰‹åœ¨å±å¹•å·¦è¾¹å‘å·¦è½¬ï¼Œå³è¾¹å‘å³è½¬
    const targetAngle = (x - 0.5) * 4; 
    STATE.targetRotationY += (targetAngle - STATE.targetRotationY) * 0.05;
}

/**
 * æ¸²æŸ“å¾ªç¯
 */
function animate() {
    requestAnimationFrame(animate);
    
    const time = performance.now() * 0.001;
    
    // æ›´æ–°Shaderæ—¶é—´
    if(treeSystem) treeSystem.material.uniforms.time.value = time;
    
    // é›ªèŠ±ä¸‹è½
    if(snowSystem) {
        const positions = snowSystem.geometry.attributes.position.array;
        for(let i=1; i<positions.length; i+=3) {
            positions[i] -= 0.2;
            if(positions[i] < -50) positions[i] = 100;
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;
    }

    // åœºæ™¯æ•´ä½“æ—‹è½¬ (ä»…åœ¨æ•£å¼€æ¨¡å¼æˆ–æ ‘æ¨¡å¼ä¸‹ï¼Œä¸”æ²¡æœ‰èšç„¦æ—¶)
    if (STATE.current !== 'FOCUS') {
        // å¹³æ»‘æ—‹è½¬
        const currentRot = scene.rotation.y;
        scene.rotation.y += (STATE.targetRotationY - currentRot) * 0.05;
        
        // å¦‚æœæ²¡æœ‰æ‰‹ï¼Œè‡ªåŠ¨æ—‹è½¬
        if(!STATE.handDetected && STATE.current === 'TREE') {
             scene.rotation.y += 0.002;
             STATE.targetRotationY = scene.rotation.y; // åŒæ­¥ï¼Œé˜²æ­¢ä¸‹æ¬¡æ‰‹ä»‹å…¥æ—¶è·³è·ƒ
        }
    }

    // æ¼‚æµ®åŠ¨ç”» (Photos)
    if (STATE.current === 'SCATTER') {
        photos.forEach((p, i) => {
            if(p !== STATE.focusedPhoto) {
                p.position.y += Math.sin(time + i) * 0.02;
            }
        });
    }

    composer.render();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

// å¯åŠ¨
window.onload = function() {
    initThree();
    setupMediaPipe();
    animate();
};

</script>
</body>
</html>
