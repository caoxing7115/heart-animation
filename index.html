<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas Dreamscape | Master Edition</title>
    <style>
        /* --- åŸºç¡€æ ·å¼ä¸å­—ä½“ --- */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital@1&display=swap');

        :root {
            --gold: #ffd700;
            --glass: rgba(20, 30, 25, 0.8);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            /* æ·±é‚ƒæå…‰èƒŒæ™¯ï¼šè§£å†³èƒŒæ™¯æ­»é»‘é—®é¢˜ */
            background: radial-gradient(circle at 50% 40%, #0a1f18 0%, #03060a 60%, #000000 100%);
            font-family: 'Cinzel', serif;
            user-select: none;
        }

        /* --- UI å±‚ --- */
        #canvas-container { position: fixed; inset: 0; z-index: 1; }
        
        #ui-layer {
            position: fixed; inset: 0; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px;
            opacity: 0; transition: opacity 1.5s ease;
        }

        /* --- åŠ è½½/ä¸Šä¼ é®ç½© --- */
        #overlay {
            position: fixed; inset: 0; z-index: 20;
            background: rgba(2, 4, 3, 0.95);
            backdrop-filter: blur(20px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-in-out, visibility 0.8s;
            pointer-events: auto;
        }

        h1 {
            color: var(--gold);
            font-size: 3.5rem;
            text-shadow: 0 0 40px rgba(255, 215, 0, 0.5);
            margin-bottom: 10px;
            letter-spacing: 6px;
            text-align: center;
            font-weight: 700;
        }

        p { color: #8fbcbb; font-family: 'Playfair Display', serif; font-size: 1.2rem; letter-spacing: 1px; margin-bottom: 40px; }

        /* é«˜çº§æ„ŸæŒ‰é’® */
        .btn-upload {
            padding: 18px 60px;
            font-size: 1.1rem;
            color: #000;
            font-weight: 800;
            background: linear-gradient(135deg, #ffd700 0%, #ffec8b 100%);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .btn-upload::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to right, transparent, rgba(255,255,255,0.8), transparent);
            transform: skewX(-25deg) translateX(-150%);
            transition: 0.5s;
        }
        
        .btn-upload:hover::after { transform: skewX(-25deg) translateX(150%); }
        .btn-upload:hover { transform: scale(1.05); box-shadow: 0 0 50px rgba(255, 215, 0, 0.6); }
        .btn-upload:disabled { filter: grayscale(1); cursor: wait; transform: scale(0.95); opacity: 0.7; }

        /* HUD ä¿¡æ¯æ  */
        .hud-top-right {
            position: absolute; top: 30px; right: 30px;
            display: flex; flex-direction: column; align-items: flex-end;
        }
        
        #video-preview {
            width: 160px; height: 120px;
            border: 2px solid var(--gold);
            border-radius: 12px;
            opacity: 0.7;
            transform: scaleX(-1); /* é•œåƒ */
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
            background: #000;
        }

        .status-badge {
            margin-top: 15px;
            padding: 8px 24px;
            background: var(--glass);
            border: 1px solid rgba(255, 215, 0, 0.3);
            color: var(--gold);
            font-weight: bold;
            font-size: 0.9rem;
            border-radius: 30px;
            text-shadow: 0 0 10px rgba(255,215,0,0.5);
            transition: all 0.3s;
        }

        .controls-hint {
            position: absolute; bottom: 40px; left: 40px;
            color: rgba(255,255,255,0.6);
            font-size: 0.9rem;
            line-height: 2.2;
            background: var(--glass);
            padding: 20px;
            border-radius: 12px;
            border-left: 2px solid var(--gold);
        }
        .key { color: #ffec8b; font-weight: bold; margin-right: 12px; }

        #file-input { display: none; }
        
        /* åŠ è½½åŠ¨ç”» */
        .loader {
            width: 48px; height: 48px;
            border: 4px solid rgba(212,175,55,0.2);
            border-radius: 50%;
            border-top-color: var(--gold);
            animation: spin 1s cubic-bezier(0.55, 0.055, 0.675, 0.19) infinite;
            margin-top: 30px;
            display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #loading-msg {
            margin-top: 15px; font-size: 0.9rem; color: var(--gold);
            opacity: 0; transition: opacity 0.5s;
        }

    </style>
    
    <!-- CDN æ¨¡å—å¼•å…¥ -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <!-- å¯åŠ¨/ä¸Šä¼ é®ç½© -->
    <div id="overlay">
        <h1>Christmas Dream</h1>
        <p>æŒ¥åŠ¨åŒæ‰‹ Â· å”¤é†’è®°å¿†æ˜Ÿæ²³</p>
        <button id="upload-btn" class="btn-upload" onclick="document.getElementById('file-input').click()">å¼€å¯æ¢¦å¢ƒ (ä¸Šä¼ ç…§ç‰‡)</button>
        <div class="loader" id="loader"></div>
        <div id="loading-msg">æ­£åœ¨æ„å»º 3D ç²’å­ä¸–ç•Œ...</div>
        <input type="file" id="file-input" multiple accept="image/*" onchange="initApp(this)">
    </div>

    <!-- äº¤äº’ UI -->
    <div id="ui-layer">
        <div class="controls-hint">
            <div><span class="key">âœŠ æ¡æ‹³</span> èšåˆ | åœ£è¯æ ‘å½¢æ€</div>
            <div><span class="key">ğŸ– å¼ æ‰‹</span> æ•£å¼€ | æ˜Ÿé™…æ¼«æ¸¸æ¨¡å¼</div>
            <div><span class="key">ğŸ¤ æåˆ</span> æŠ“å– | é è¿‘ç…§ç‰‡ä»¥æŸ¥çœ‹</div>
        </div>
        <div class="hud-top-right">
            <video id="video-preview" playsinline></video>
            <div class="status-badge" id="status-text">ç³»ç»Ÿå°±ç»ª</div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- ç²’å­ç€è‰²å™¨ (Vertex Shader) -->
    <script type="x-shader/x-vertex" id="vertexShader">
        attribute float size;
        attribute vec3 customColor;
        attribute float flashOffset;
        
        varying vec3 vColor;
        varying float vAlpha;
        
        uniform float uTime;
        uniform float uPixelRatio;
        uniform float uMixFactor;
        
        attribute vec3 targetTree;
        attribute vec3 targetScatter;

        void main() {
            // æ··åˆæ ‘å’Œæ•£å¼€çš„ä½ç½®
            vec3 pos = mix(targetTree, targetScatter, uMixFactor);
            
            // æ•£å¼€æ—¶çš„åŠ¨æ€æµ®åŠ¨å™ªéŸ³
            if (uMixFactor > 0.1) {
                float amp = 1.2; 
                pos.x += sin(uTime * 0.5 + pos.y * 0.1) * amp;
                pos.y += cos(uTime * 0.3 + pos.x * 0.1) * amp;
                pos.z += sin(uTime * 0.4 + pos.x * 0.1) * amp;
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            
            // å‘¼å¸é—ªçƒè®¡ç®—
            float flash = sin(uTime * 3.5 + flashOffset); 
            float brightness = 0.6 + 0.4 * flash; 
            
            // é¢œè‰²åŠ¨æ€å˜åŒ–ï¼šæ•£å¼€æ—¶ç¨å¾®å˜å†·
            vec3 finalColor = customColor;
            if(uMixFactor > 0.8) {
                finalColor = mix(customColor, vec3(0.7, 0.9, 1.0), 0.4);
            }
            vColor = finalColor;

            // ç²’å­å¤§å°éšè·ç¦»è¡°å‡
            gl_PointSize = size * uPixelRatio * (280.0 / -mvPosition.z) * brightness;
            gl_Position = projectionMatrix * mvPosition;
            
            vAlpha = brightness;
        }
    </script>

    <!-- ç²’å­ç€è‰²å™¨ (Fragment Shader) -->
    <script type="x-shader/x-fragment" id="fragmentShader">
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
            // ç»˜åˆ¶æŸ”å’Œåœ†å½¢ç²’å­
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            // å¾„å‘æ¸å˜æ¨¡æ‹Ÿè¾‰å…‰
            float strength = 1.0 / (dist * 12.0);
            strength = clamp(strength, 0.0, 1.0);
            strength *= (1.0 - smoothstep(0.4, 0.5, dist));

            if (strength < 0.01) discard;

            gl_FragColor = vec4(vColor, strength * vAlpha);
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- é…ç½®å‚æ•° ---
        const CONSTANTS = {
            PARTICLE_COUNT: 22000, // ç²’å­æ•°é‡
            ORNAMENT_COUNT: 180,   // è£…é¥°ç‰©æ•°é‡
            TREE_HEIGHT: 45,
            TREE_RADIUS: 16,
            COLORS: [
                new THREE.Color('#ffdd00'), // é‡‘
                new THREE.Color('#d10000'), // çº¢
                new THREE.Color('#00ff55'), // ç»¿
                new THREE.Color('#ffffff'), // ç™½
                new THREE.Color('#00ccff')  // å†°è“
            ]
        };

        const STATE = { TREE: 0, SCATTER: 1, DETAIL: 2, current: 0 };

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer;
        let particleSystem, particleUniforms;
        let ornaments = [];
        let photoMeshes = [];
        let cursorSprite;
        
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        // äº¤äº’çŠ¶æ€
        let selectedPhoto = null;
        let hoveredPhoto = null;
        let targetMix = 0;
        let currentMix = 0;
        let sceneRotationTarget = { x: 0, y: 0 };
        
        let lastGestureTime = 0;
        let audioCtx;

        // --- éŸ³æ•ˆç³»ç»Ÿ (Web Audio API) ---
        const SoundFX = {
            init: () => {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    audioCtx = new AudioContext();
                } catch(e) { console.warn('Audio not supported'); }
            },
            playTone: (freq, type, duration) => {
                if(!audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            playSparkle: () => SoundFX.playTone(800, 'sine', 0.6), // åˆ‡æ¢çŠ¶æ€
            playSnap: () => SoundFX.playTone(200, 'triangle', 0.1) // æŠ“å–
        };

        // --- ç¨‹åºå…¥å£ (ä¿®å¤Bugçš„å…³é”®) ---
        window.initApp = async (input) => {
            const files = input.files;
            if (!files || files.length === 0) return;
            
            // 1. ç«‹å³é”å®š UIï¼Œé˜²æ­¢é‡å¤æ“ä½œ
            const btn = document.getElementById('upload-btn');
            const loader = document.getElementById('loader');
            const msg = document.getElementById('loading-msg');
            
            btn.disabled = true;
            btn.style.opacity = '0';
            setTimeout(() => btn.style.display = 'none', 400); // ç§»é™¤æŒ‰é’®
            
            loader.style.display = 'block';
            msg.style.opacity = '1';

            // 2. åˆå§‹åŒ–ç³»ç»Ÿ
            SoundFX.init();
            initThree();
            
            // 3. å¤„ç†å›¾ç‰‡ (ä½¿ç”¨ Promise.allSettled é˜²æ­¢å•å¼ å›¾ç‰‡å¤±è´¥å¡æ­»æ•´ä¸ªæµç¨‹)
            try {
                await createPhotoGallery(files);
            } catch (err) {
                console.error("Critical Gallery Error:", err);
                alert("éƒ¨åˆ†ç…§ç‰‡åŠ è½½å¤±è´¥ï¼Œä½†æ¢¦å¢ƒä¾ç„¶ç»§ç»­...");
            }

            // 4. è¿‡æ¸¡åŠ¨ç”» (å¼ºåˆ¶æ‰§è¡Œ)
            const overlay = document.getElementById('overlay');
            overlay.style.opacity = '0';
            overlay.style.visibility = 'hidden'; // ç¡®ä¿ç‚¹å‡»ç©¿é€
            
            document.getElementById('ui-layer').style.opacity = '1';

            // 5. å¯åŠ¨æ‘„åƒå¤´ (ä»…åœ¨å®‰å…¨ä¸Šä¸‹æ–‡)
            if (location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
                initMediaPipe();
            } else {
                document.getElementById('status-text').innerText = "âš ï¸ éHTTPSç¯å¢ƒï¼Œæ‰‹åŠ¿ä¸å¯ç”¨";
            }
            
            // 6. å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        };

        function initThree() {
            const container = document.getElementById('canvas-container');

            // åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020406, 0.012); // é…åˆèƒŒæ™¯çš„é›¾æ•ˆ

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 75); // åˆå§‹è§†è§’

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                powerPreference: "high-performance",
                alpha: true // å…è®¸CSSèƒŒæ™¯é€è¿‡æ¥
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.2; // æé«˜æ•´ä½“äº®åº¦
            container.appendChild(renderer.domElement);

            // åæœŸå¤„ç† (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.25; // ä¿æŠ¤ç…§ç‰‡ä¸è¿‡æ›
            bloomPass.strength = 1.0; 
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç¯å…‰
            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            const sunLight = new THREE.DirectionalLight(0xffaa00, 1.5);
            sunLight.position.set(20, 50, 30);
            scene.add(ambient, sunLight);

            // åˆ›å»ºåœºæ™¯å…ƒç´ 
            createStaticStars(); // èƒŒæ™¯æ˜Ÿç©º
            createAdvancedParticles(); // ç²’å­ç³»ç»Ÿ
            createDecorations(); // è£…é¥°çƒ
            createFairyCursor(); // äº¤äº’å…‰æ ‡
            
            window.addEventListener('resize', onResize);
        }

        // --- è§†è§‰ç»„ä»¶ ---

        function createStaticStars() {
            const geo = new THREE.BufferGeometry();
            const pos = []; const sizes = [];
            for(let i=0; i<3000; i++) {
                const r = 200 + Math.random() * 300; 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                pos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                sizes.push(Math.random() * 2.0);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            const mat = new THREE.PointsMaterial({ color: 0x88ccff, size: 1.0, transparent: true, opacity: 0.6, sizeAttenuation: true });
            scene.add(new THREE.Points(geo, mat));
        }

        function createFairyCursor() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "#ffffff"; ctx.beginPath(); ctx.arc(16,16,5,0,Math.PI*2); ctx.fill();
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255, 255, 200, 1)'); grad.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, color: 0xffdd00, blending: THREE.AdditiveBlending, transparent: true });
            
            cursorSprite = new THREE.Sprite(mat);
            cursorSprite.scale.set(1.5, 1.5, 1);
            cursorSprite.visible = false;
            
            const light = new THREE.PointLight(0xffaa00, 2, 8);
            cursorSprite.add(light);
            scene.add(cursorSprite);
        }

        function createAdvancedParticles() {
            const geometry = new THREE.BufferGeometry();
            const count = CONSTANTS.PARTICLE_COUNT;
            const targetTree = []; const targetScatter = [];
            const colors = []; const sizes = []; const flashOffsets = [];

            for (let i = 0; i < count; i++) {
                // æ ‘å½¢æ€
                const t = Math.random();
                const angle = t * Math.PI * 2 * 35; // èºæ—‹åœˆæ•°
                const radius = (1 - t) * CONSTANTS.TREE_RADIUS;
                const rOffset = Math.random() * 2; 
                targetTree.push(Math.cos(angle)*(radius+rOffset), (t*CONSTANTS.TREE_HEIGHT)-(CONSTANTS.TREE_HEIGHT/2), Math.sin(angle)*(radius+rOffset));

                // æ•£å¼€å½¢æ€ (çƒå½¢éšæœº)
                const phi = Math.acos(-1 + (2 * i) / count);
                const theta = Math.sqrt(count * Math.PI) * phi;
                const rScatter = 40 + Math.random() * 60;
                targetScatter.push(rScatter * Math.cos(theta) * Math.sin(phi), rScatter * Math.sin(theta) * Math.sin(phi), rScatter * Math.cos(phi));

                const col = CONSTANTS.COLORS[Math.floor(Math.random() * CONSTANTS.COLORS.length)];
                colors.push(col.r, col.g, col.b);
                sizes.push(Math.random() * 0.6 + 0.2); 
                flashOffsets.push(Math.random() * Math.PI * 2);
            }
            geometry.setAttribute('targetTree', new THREE.Float32BufferAttribute(targetTree, 3));
            geometry.setAttribute('targetScatter', new THREE.Float32BufferAttribute(targetScatter, 3));
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(targetTree, 3));
            geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('flashOffset', new THREE.Float32BufferAttribute(flashOffsets, 1));

            particleUniforms = { uTime: { value: 0 }, uPixelRatio: { value: renderer.getPixelRatio() }, uMixFactor: { value: 0.0 } };
            const material = new THREE.ShaderMaterial({
                uniforms: particleUniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            particleSystem = new THREE.Points(geometry, material);
