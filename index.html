<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Dream - Enhanced Gesture Control</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020505; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        /* é¢„è§ˆçª—å£ç°åœ¨åªä½œä¸ºè°ƒè¯•å‚è€ƒï¼Œå› ä¸ºæˆ‘ä»¬æœ‰äº†3Då…‰æ ‡ */
        #video-preview {
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; 
            border: 1px solid rgba(212, 175, 55, 0.3); border-radius: 8px; transform: scaleX(-1); opacity: 0.5;
        }

        #status-bar {
            color: #D4AF37; text-shadow: 0 0 10px #D4AF37; font-size: 14px; background: rgba(0,0,0,0.6);
            padding: 15px; border-radius: 8px; pointer-events: auto; max-width: 350px;
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
        
        #upload-btn {
            pointer-events: auto; cursor: pointer; background: rgba(212, 175, 55, 0.1); border: 1px solid #D4AF37;
            color: #D4AF37; padding: 8px 16px; border-radius: 20px; transition: 0.3s; text-transform: uppercase;
            font-size: 12px; font-weight: bold; margin-top: 15px; display: inline-block; text-align: center;
        }
        #upload-btn:hover { background: #D4AF37; color: #000; box-shadow: 0 0 15px #D4AF37; }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100;
            display: flex; justify-content: center; align-items: center; color: #D4AF37; flex-direction: column;
            transition: opacity 1s;
        }
        .spinner {
            width: 40px; height: 40px; border: 2px solid transparent; border-top-color: #D4AF37; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .highlight-text { color: #fff; text-shadow: 0 0 5px #fff; }
    </style>
    
    <!-- å¼•å…¥åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <div>SUMMONING ELVES...</div>
</div>

<div id="ui-layer">
    <div id="status-bar">
        <div>STATE: <span id="state-text" class="highlight-text">TREE (MERGED)</span></div>
        <div style="font-size: 12px; margin-top:5px; color:#aaa; line-height: 1.6;">
            ğŸ‘Š FIST: Merge Tree<br>
            ğŸ– OPEN: Scatter Mode<br>
            âœ¨ <strong>CURSOR:</strong> Point at photo<br>
            ğŸ‘Œ <strong>PINCH:</strong> Grab highlighted photo
        </div>
        <label id="upload-btn">
            + Add Memories
            <input type="file" id="file-input" multiple accept="image/*" style="display:none;">
        </label>
    </div>
</div>

<video id="video-preview" playsinline></video>
<div id="canvas-container"></div>

<script>
/**
 * é…ç½®
 */
const CONFIG = {
    particleCount: 40000,
    treeHeight: 60,
    treeRadius: 25,
    colors: [0xD4AF37, 0xC41E3A, 0x2E8B57], 
    bloom: { strength: 1.6, radius: 0.5, threshold: 0.15 },
    cursorSmoothing: 0.15 // é¼ æ ‡å¹³æ»‘ç³»æ•° (è¶Šå°è¶Šå¹³æ»‘ï¼Œä½†å»¶è¿Ÿè¶Šé«˜)
};

const STATE = {
    current: 'TREE',
    handDetected: false,
    focusedPhoto: null,
    hoveredPhoto: null, // å½“å‰æ‚¬åœçš„ç…§ç‰‡
    rotationSpeed: 0,
    targetRotationY: 0
};

// æ ¸å¿ƒå˜é‡
let scene, camera, renderer, composer;
let treeSystem, snowSystem, cursorSprite;
let photos = []; 
let raycaster = new THREE.Raycaster();

// åæ ‡ç³»ç»Ÿå˜é‡
let rawMouse = new THREE.Vector2();     // åŸå§‹æ‰‹åŠ¿åæ ‡
let smoothedMouse = new THREE.Vector2();// å¹³æ»‘åçš„åæ ‡
let cursorWorldPos = new THREE.Vector3(); // å…‰æ ‡åœ¨3Dç©ºé—´çš„ä½ç½®

/**
 * 1. åˆå§‹åŒ–
 */
function initThree() {
    const container = document.getElementById('canvas-container');
    
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020505, 0.02);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 85);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    container.appendChild(renderer.domElement);

    // åå¤„ç†
    const renderScene = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        CONFIG.bloom.strength, CONFIG.bloom.radius, CONFIG.bloom.threshold
    );
    composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // ç¯å…‰
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const pLight = new THREE.PointLight(0xD4AF37, 1.2, 100);
    pLight.position.set(0, 30, 20);
    scene.add(pLight);

    // åˆ›å»ºåœºæ™¯ç‰©ä½“
    createTreeParticles();
    createSnow();
    createCursor(); // æ–°å¢ï¼šç²¾çµæ¸¸æ ‡
    
    window.addEventListener('resize', onWindowResize, false);
    
    // ç§»é™¤Loading
    setTimeout(() => {
        document.getElementById('loader').style.opacity = '0';
        setTimeout(() => document.getElementById('loader').style.display = 'none', 1000);
    }, 1500);
}

/**
 * æ–°å¢ï¼šç²¾çµæ¸¸æ ‡ (Fairy Cursor)
 * ä¸€ä¸ªæ·¡è‰²ã€é—ªçƒçš„å°å…‰ç‚¹ï¼Œè·Ÿéšæ‰‹åŠ¿
 */
function createCursor() {
    // åŠ¨æ€ç”Ÿæˆä¸€ä¸ªå‘å…‰åœ†ç‚¹çº¹ç†
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
    grad.addColorStop(0, 'rgba(255, 255, 230, 1)'); // ä¸­å¿ƒäº®ç™½
    grad.addColorStop(0.4, 'rgba(212, 175, 55, 0.5)'); // ä¸­é—´é‡‘
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,64,64);

    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ 
        map: texture, 
        color: 0xffffff, 
        transparent: true, 
        opacity: 0, // åˆå§‹éšè—ï¼Œæœ‰æ‰‹æ‰æ˜¾ç¤º
        depthTest: false // å§‹ç»ˆåœ¨æœ€å‰
    });

    cursorSprite = new THREE.Sprite(material);
    cursorSprite.scale.set(3, 3, 1);
    cursorSprite.renderOrder = 999;
    scene.add(cursorSprite);
}

/**
 * 2. ç²’å­æ ‘ç³»ç»Ÿ
 */
function createTreeParticles() {
    const geometry = new THREE.BufferGeometry();
    const positions = [], colors = [], sizes = [];
    const originalPos = [], scatteredPos = [];
    const colorObj = new THREE.Color();

    for (let i = 0; i < CONFIG.particleCount; i++) {
        // æ ‘å½¢æ€ (èºæ—‹åœ†é”¥)
        const y = Math.random() * CONFIG.treeHeight; 
        const r = (CONFIG.treeHeight - y) / CONFIG.treeHeight * CONFIG.treeRadius;
        const angle = y * 1.5 + Math.random() * Math.PI * 2;
        const offset = Math.random() * 2;
        
        const tx = Math.cos(angle) * (r + offset);
        const tz = Math.sin(angle) * (r + offset);
        const ty = y - CONFIG.treeHeight / 2;

        positions.push(tx, ty, tz);
        originalPos.push(tx, ty, tz);

        // æ•£å¼€å½¢æ€
        scatteredPos.push((Math.random()-0.5)*120, (Math.random()-0.5)*120, (Math.random()-0.5)*120);

        // é¢œè‰²
        const rand = Math.random();
        let hex = rand > 0.95 ? CONFIG.colors[0] : (rand > 0.85 ? CONFIG.colors[1] : CONFIG.colors[2]);
        colorObj.setHex(hex);
        colors.push(colorObj.r, colorObj.g, colorObj.b);
        sizes.push(Math.random() * 0.5 + 0.1);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
    geometry.setAttribute('aScatter', new THREE.Float32BufferAttribute(scatteredPos, 3));
    geometry.setAttribute('aOriginal', new THREE.Float32BufferAttribute(originalPos, 3));

    const material = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            pointTexture: { value: new THREE.TextureLoader().load('https://assets.codepen.io/127738/dotTexture.png') },
            mixVal: { value: 0.0 }
        },
        vertexShader: `
            attribute float size; attribute vec3 color; attribute vec3 aScatter; attribute vec3 aOriginal;
            varying vec3 vColor; uniform float time; uniform float mixVal;
            void main() {
                vColor = color;
                vec3 pos = mix(aOriginal, aScatter, mixVal);
                float pulse = sin(time * 3.0 + pos.y * 0.1) * 0.2 + 1.0;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = size * pulse * (350.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            uniform sampler2D pointTexture; varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
                if (gl_FragColor.a < 0.5) discard;
            }
        `,
        depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
    });

    treeSystem = new THREE.Points(geometry, material);
    scene.add(treeSystem);
}

function createSnow() {
    const geo = new THREE.BufferGeometry();
    const verts = [];
    for(let i=0; i<3000; i++) verts.push((Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*200);
    geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
    snowSystem = new THREE.Points(geo, new THREE.PointsMaterial({color:0xffffff, size:0.6, transparent:true, opacity:0.6}));
    scene.add(snowSystem);
}

/**
 * 3. ç…§ç‰‡ä¸Šä¼ 
 */
document.getElementById('file-input').addEventListener('change', (e) => {
    const files = e.target.files;
    if(!files.length) return;
    for(let i=0; i<Math.min(files.length, 15); i++) {
        const r = new FileReader();
        r.onload = (evt) => createPolaroid(evt.target.result);
        r.readAsDataURL(files[i]);
    }
});

function createPolaroid(url) {
    new THREE.TextureLoader().load(url, (tex) => {
        const grp = new THREE.Group();
        
        // è¾¹æ¡†
        const frame = new THREE.Mesh(new THREE.PlaneGeometry(6, 7.2), new THREE.MeshBasicMaterial({color:0xffffff}));
        // ç…§ç‰‡
        const pic = new THREE.Mesh(new THREE.PlaneGeometry(5.2, 5.2), new THREE.MeshBasicMaterial({map:tex}));
        pic.position.set(0, 0.6, 0.05);
        
        grp.add(frame); grp.add(pic);
        
        // æ ‡è®°æ­¤Meshå¯äº¤äº’
        frame.userData.isInteractable = true;
        
        // éšæœºä½ç½®
        const y = (Math.random()-0.5) * CONFIG.treeHeight;
        const r = ((CONFIG.treeHeight/2 - y)/CONFIG.treeHeight * CONFIG.treeRadius) + 4;
        const ang = Math.random() * 6.28;
        
        grp.userData = {
            treePos: new THREE.Vector3(Math.cos(ang)*r, y, Math.sin(ang)*r),
            treeRot: new THREE.Euler(0, -ang, 0),
            scatterPos: new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*80, (Math.random()-0.5)*50),
            scatterRot: new THREE.Euler(Math.random()*3, Math.random()*3, 0)
        };
        
        grp.position.copy(grp.userData.treePos);
        grp.rotation.copy(grp.userData.treeRot);
        grp.lookAt(0, y, 0);
        
        scene.add(grp);
        photos.push(grp);
        
        // è¿›åœºç‰¹æ•ˆ
        gsap.from(grp.scale, {x:0, y:0, z:0, duration:1, ease:"back.out(1.7)"});
    });
}

/**
 * 4. MediaPipe æ‰‹åŠ¿é€»è¾‘ (å«å¹³æ»‘å¤„ç†)
 */
function setupMediaPipe() {
    const vid = document.getElementById('video-preview');
    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.6 });
    hands.onResults(onHandResults);
    
    new Camera(vid, {
        onFrame: async () => await hands.send({image: vid}),
        width: 320, height: 240
    }).start();
}

function onHandResults(res) {
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        STATE.handDetected = true;
        const landmarks = res.multiHandLandmarks[0];
        
        // 1. æ›´æ–°æ‰‹éƒ¨æ˜ å°„åæ ‡ (ä½¿ç”¨é£ŸæŒ‡å°–)
        // MediaPipe xæ˜¯é•œåƒçš„ï¼Œéœ€è¦ç¿»è½¬
        const ndcX = (1 - landmarks[8].x) * 2 - 1; 
        const ndcY = (1 - landmarks[8].y) * 2 - 1;
        rawMouse.set(ndcX, ndcY);

        // 2. è¯†åˆ«æ‰‹åŠ¿
        const gesture = detectGesture(landmarks);
        
        // 3. æ‰§è¡ŒçŠ¶æ€å˜æ›´
        handleStateChange(gesture);
        
        // 4. æ—‹è½¬æ§åˆ¶ (åœ¨ SCATTER æ€ä¸‹)
        if (STATE.current === 'SCATTER' && gesture !== 'PINCH') {
            const palmX = landmarks[9].x; 
            const target = (0.5 - palmX) * 4; // ä¿®æ­£æ–¹å‘
            STATE.targetRotationY += (target - STATE.targetRotationY) * 0.05;
        }
        
    } else {
        STATE.handDetected = false;
        cursorSprite.visible = false;
    }
}

function detectGesture(lm) {
    const d = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
    const wrist = lm[0];
    
    // æåˆï¼šæ‹‡æŒ‡å°–(4)ä¸é£ŸæŒ‡å°–(8)è·ç¦»
    const pinchDist = d(lm[4], lm[8]);
    
    // æ¡æ‹³ï¼šæŒ‡å°–é è¿‘æ‰‹è…•
    const isFist = [8, 12, 16, 20].every(i => d(lm[i], wrist) < 0.25);
    
    // å¼ å¼€
    const isOpen = [8, 12, 16, 20].every(i => d(lm[i], wrist) > 0.35);

    if (pinchDist < 0.05) return 'PINCH'; // è°ƒå°é˜ˆå€¼æé«˜æåˆç²¾åº¦è¦æ±‚
    if (isFist) return 'FIST';
    if (isOpen) return 'OPEN';
    return 'UNKNOWN';
}

function handleStateChange(gesture) {
    const status = document.getElementById('state-text');
    
    if (gesture === 'FIST' && STATE.current !== 'TREE') {
        STATE.current = 'TREE';
        status.innerText = "TREE (MERGED)";
        exitFocus();
        
        gsap.to(treeSystem.material.uniforms.mixVal, {value:0, duration:2});
        gsap.to(camera.position, {z:85, duration:2});
        
        photos.forEach(p => {
            gsap.to(p.position, {x:p.userData.treePos.x, y:p.userData.treePos.y, z:p.userData.treePos.z, duration:1.5});
            gsap.to(p.rotation, {x:p.userData.treeRot.x, y:p.userData.treeRot.y, z:p.userData.treeRot.z, duration:1.5});
        });
    }
    else if (gesture === 'OPEN' && STATE.current !== 'SCATTER') {
        STATE.current = 'SCATTER';
        status.innerText = "SCATTER (FLOATING)";
        exitFocus();
        
        gsap.to(treeSystem.material.uniforms.mixVal, {value:1, duration:2});
        
        photos.forEach(p => {
            gsap.to(p.position, {x:p.userData.scatterPos.x, y:p.userData.scatterPos.y, z:p.userData.scatterPos.z, duration:2});
            gsap.to(p.rotation, {x:p.userData.scatterRot.x, y:p.userData.scatterRot.y, z:p.userData.scatterRot.z, duration:2});
        });
    }
    else if (gesture === 'PINCH') {
        // åªæœ‰åœ¨å…‰æ ‡å½“å‰æ­£å¥½æ‚¬åœåœ¨ç…§ç‰‡ä¸Šæ—¶ï¼Œæ‰è§¦å‘æŠ“å–
        if (STATE.hoveredPhoto && STATE.current !== 'FOCUS') {
            enterFocus(STATE.hoveredPhoto);
        }
    }
}

function enterFocus(obj) {
    STATE.current = 'FOCUS';
    STATE.focusedPhoto = obj;
    document.getElementById('state-text').innerText = "MEMORY (FOCUSED)";
    
    // ç›®æ ‡ä½ç½®ï¼šç›¸æœºå‰æ–¹å›ºå®šè·ç¦»
    const target = new THREE.Vector3(0, 0, -15).applyMatrix4(camera.matrixWorld);
    
    gsap.to(obj.position, {x:target.x, y:target.y, z:target.z, duration:1, ease:"power2.out", onUpdate: () => obj.lookAt(camera.position)});
    gsap.to(obj.scale, {x:2.5, y:2.5, z:2.5, duration:1});
    gsap.to(obj.rotation, {z:0, duration:1}); // æ‰¶æ­£
}

function exitFocus() {
    if(STATE.focusedPhoto) {
        gsap.to(STATE.focusedPhoto.scale, {x:1, y:1, z:1, duration:0.5});
        STATE.focusedPhoto = null;
    }
}

/**
 * 5. æ¸²æŸ“å¾ªç¯ä¸æ ¸å¿ƒäº¤äº’é€»è¾‘
 */
function animate() {
    requestAnimationFrame(animate);
    const time = performance.now() * 0.001;

    // A. åæ ‡å¹³æ»‘ (å…³é”®æ”¹è¿›)
    // æ¯ä¸€å¸§åªå‘ç›®æ ‡ä½ç½®ç§»åŠ¨ä¸€å°æ­¥ï¼Œæ¶ˆé™¤æŠ–åŠ¨
    smoothedMouse.lerp(rawMouse, CONFIG.cursorSmoothing);

    // B. æ›´æ–°å…‰æ ‡ä½ç½®
    if (STATE.handDetected) {
        cursorSprite.visible = true;
        
        // ä½¿ç”¨å¹³æ»‘åçš„åæ ‡è¿›è¡Œå°„çº¿æ£€æµ‹
        raycaster.setFromCamera(smoothedMouse, camera);
        
        // é»˜è®¤å…‰æ ‡åœ¨ç›¸æœºå‰æ–¹30å•ä½æ¼‚æµ®
        const defaultCursorPos = new THREE.Vector3(smoothedMouse.x, smoothedMouse.y, 0.5)
            .unproject(camera).normalize().multiplyScalar(30).add(camera.position);
            
        cursorSprite.position.copy(defaultCursorPos);
        
        // é—ªçƒæ•ˆæœ
        cursorSprite.material.opacity = 0.5 + Math.sin(time * 10) * 0.3;

        // C. æ‚¬åœæ£€æµ‹ (Hover Logic)
        // åªæœ‰åœ¨ SCATTER æ¨¡å¼ä¸‹å…è®¸äº¤äº’
        if (STATE.current === 'SCATTER') {
            // æ£€æµ‹ç…§ç‰‡ (photos æ•°ç»„å­˜å‚¨çš„æ˜¯Groupï¼Œæˆ‘ä»¬éœ€è¦æ£€æµ‹å­å¯¹è±¡å¹¶å‘ä¸ŠæŸ¥æ‰¾)
            const intersects = raycaster.intersectObjects(scene.children, true);
            let found = null;
            
            for (let i = 0; i < intersects.length; i++) {
                // æ‰¾åˆ°æœ€è¿‘çš„æ‹ç«‹å¾—Group
                if (intersects[i].object.parent && photos.includes(intersects[i].object.parent)) {
                    found = intersects[i].object.parent;
                    // è®©å…‰æ ‡å¸é™„åˆ°ç‰©ä½“è¡¨é¢
                    cursorSprite.position.copy(intersects[i].point); 
                    break;
                }
            }

            // å¤„ç†æ‚¬åœçŠ¶æ€å˜åŒ–
            if (found !== STATE.hoveredPhoto) {
                // ç¦»å¼€æ—§çš„
                if (STATE.hoveredPhoto) {
                    gsap.to(STATE.hoveredPhoto.scale, {x:1, y:1, z:1, duration:0.3});
                    // æ¢å¤é¢œè‰²ï¼ˆå¯é€‰ï¼‰
                }
                // è¿›å…¥æ–°çš„
                if (found) {
                    gsap.to(found.scale, {x:1.2, y:1.2, z:1.2, duration:0.3, ease:"back.out"});
                }
                STATE.hoveredPhoto = found;
            }
        } else {
             STATE.hoveredPhoto = null;
        }
    }

    // D. åœºæ™¯åŠ¨ç”»
    treeSystem.material.uniforms.time.value = time;
    
    // é›ªèŠ±å¾ªç¯
    const snowPos = snowSystem.geometry.attributes.position.array;
    for(let i=1; i<snowPos.length; i+=3) {
        snowPos[i] -= 0.15;
        if(snowPos[i] < -60) snowPos[i] = 100;
    }
    snowSystem.geometry.attributes.position.needsUpdate = true;

    // æ—‹è½¬åœºæ™¯
    if (STATE.current !== 'FOCUS') {
        if(!STATE.handDetected && STATE.current === 'TREE') STATE.targetRotationY += 0.0015;
        scene.rotation.y += (STATE.targetRotationY - scene.rotation.y) * 0.05;
    }
    
    // æ¼‚æµ®å¾®åŠ¨
    if(STATE.current === 'SCATTER') {
        photos.forEach((p,i) => {
            if(p !== STATE.focusedPhoto && p !== STATE.hoveredPhoto) {
                p.position.y += Math.sin(time + i)*0.015;
            }
        });
    }

    composer.render();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

window.onload = () => { initThree(); setupMediaPipe(); animate(); };

</script>
</body>
</html>
