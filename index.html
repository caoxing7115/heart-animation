<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Dream - Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020505; font-family: 'Courier New', Courier, monospace; cursor: none; /* éšè—é»˜è®¤é¼ æ ‡ */ }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        /* æ‘„åƒå¤´é¢„è§ˆ */
        #video-preview {
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; 
            border: 2px solid #D4AF37; border-radius: 8px; transform: scaleX(-1); opacity: 0.7;
        }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #status-bar {
            color: #D4AF37; text-shadow: 0 0 10px #D4AF37; font-size: 14px; background: rgba(0,0,0,0.5);
            padding: 10px; border-radius: 4px; pointer-events: auto; max-width: 350px;
        }
        
        /* ä¸Šä¼ æŒ‰é’® */
        #upload-btn {
            pointer-events: auto; cursor: pointer; background: rgba(212, 175, 55, 0.2); border: 1px solid #D4AF37;
            color: #D4AF37; padding: 10px 20px; border-radius: 20px; transition: 0.3s; text-transform: uppercase;
            font-weight: bold; margin-top: 10px; display: inline-block; text-align: center;
        }
        #upload-btn:hover { background: #D4AF37; color: #000; box-shadow: 0 0 20px #D4AF37; }
        
        /* åŠ è½½é®ç½© */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100;
            display: flex; justify-content: center; align-items: center; color: #D4AF37; flex-direction: column;
            transition: opacity 1s;
        }
        .spinner {
            width: 50px; height: 50px; border: 3px solid transparent; border-top-color: #D4AF37; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- ç²¾çµæ¸¸æ ‡æ ·å¼ (æ–°å¢) --- */
        #fairy-cursor {
            position: fixed; top: 0; left: 0; z-index: 9999; pointer-events: none;
            width: 0; height: 0; /* ä½¿ç”¨transformå®šä½ */
        }
        .cursor-core {
            width: 12px; height: 12px; background: #fff; border-radius: 50%;
            box-shadow: 0 0 15px 5px #D4AF37, 0 0 30px 10px rgba(212, 175, 55, 0.5);
            position: absolute; transform: translate(-50%, -50%);
            animation: twinkle 1.5s infinite ease-in-out;
        }
        .cursor-ring {
            width: 30px; height: 30px; border: 1px solid rgba(255,255,255,0.5); border-radius: 50%;
            position: absolute; transform: translate(-50%, -50%);
            animation: ripple 2s infinite linear;
        }
        /* æŠ“å–çŠ¶æ€ä¸‹çš„å…‰æ ‡æ ·å¼ */
        #fairy-cursor.grabbing .cursor-core {
            background: #ff4444; box-shadow: 0 0 20px 8px #ff0000; scale: 1.5;
        }

        @keyframes twinkle { 
            0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); } 
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); } 
        }
        @keyframes ripple {
            0% { width: 10px; height: 10px; opacity: 1; }
            100% { width: 50px; height: 50px; opacity: 0; }
        }

        .guide { font-size: 12px; color: #aaa; margin-top: 5px; line-height: 1.6; }
    </style>
    
    <!-- å¼•å…¥åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <div>INITIALIZING CHRISTMAS MAGIC...</div>
    <div style="font-size: 12px; margin-top:10px; color:#666;">Please allow camera access</div>
</div>

<!-- ç²¾çµæ¸¸æ ‡ -->
<div id="fairy-cursor">
    <div class="cursor-core"></div>
    <div class="cursor-ring"></div>
</div>

<div id="ui-layer">
    <div id="status-bar">
        <div><strong>CURRENT STATE:</strong> <span id="state-text">TREE (MERGED)</span></div>
        <div class="guide">
            ğŸ‘Š æ¡æ‹³: èšåˆæˆæ ‘<br>
            ğŸ– å¼ å¼€: æ•£å¼€ç…§ç‰‡ (æ•£å¼€åæ‰èƒ½æŠ“å–)<br>
            ğŸ‘Œ æåˆ: <b>æŠ“å–ç…§ç‰‡</b> (å¯¹å‡†å‘å…‰ç…§ç‰‡)
        </div>
        <label id="upload-btn">
            Upload Memories (Photos)
            <input type="file" id="file-input" multiple accept="image/*" style="display:none;">
        </label>
    </div>
</div>

<video id="video-preview" playsinline></video>
<div id="canvas-container"></div>

<script>
/**
 * æ ¸å¿ƒé…ç½®ä¸çŠ¶æ€ç®¡ç†
 */
const CONFIG = {
    particleCount: 45000,
    treeHeight: 60,
    treeRadius: 25,
    colors: [0xD4AF37, 0xC41E3A, 0x2E8B57],
    bloom: { strength: 1.5, radius: 0.4, threshold: 0.15 } // ç¨å¾®é™ä½Bloomé˜²æ­¢è¿‡æ›
};

const STATE = {
    current: 'TREE',
    handDetected: false,
    focusedPhoto: null,
    hoveredPhoto: null, // æ–°å¢ï¼šå½“å‰æ‚¬åœçš„ç…§ç‰‡
    rotationSpeed: 0,
    targetRotationY: 0
};

// å…¨å±€å˜é‡
let scene, camera, renderer, composer;
let treeSystem, snowSystem;
let photos = [];
let raycaster = new THREE.Raycaster();

// æ¸¸æ ‡ä¸å¹³æ»‘ç›¸å…³
let mouse = new THREE.Vector2(-999, -999); // Three.js ç”¨çš„å½’ä¸€åŒ–åæ ‡
let rawMouse = new THREE.Vector2(-999, -999); // MediaPipe åŸå§‹åæ ‡
let cursorDiv = document.getElementById('fairy-cursor');

/**
 * 1. Three.js åˆå§‹åŒ–ä¸åœºæ™¯æ„å»º
 */
function initThree() {
    const container = document.getElementById('canvas-container');
    
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020505, 0.015);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 20, 80);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ReinhardToneMapping;
    container.appendChild(renderer.domElement);

    const renderScene = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        CONFIG.bloom.strength, CONFIG.bloom.radius, CONFIG.bloom.threshold
    );
    
    composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xD4AF37, 1.2, 100);
    pointLight.position.set(0, 30, 20);
    scene.add(pointLight);

    createTreeParticles();
    createSnow();
    
    window.addEventListener('resize', onWindowResize, false);
    
    setTimeout(() => {
        document.getElementById('loader').style.opacity = '0';
        setTimeout(() => document.getElementById('loader').style.display = 'none', 1000);
    }, 2000);
}

/**
 * 2. ç²’å­ç³»ç»Ÿ
 */
function createTreeParticles() {
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    const sizes = [];
    const originalPos = [];
    const scatteredPos = [];
    const colorObj = new THREE.Color();

    for (let i = 0; i < CONFIG.particleCount; i++) {
        const y = Math.random() * CONFIG.treeHeight; 
        const radiusAtY = (CONFIG.treeHeight - y) / CONFIG.treeHeight * CONFIG.treeRadius;
        const angle = y * 1.5 + Math.random() * Math.PI * 2;
        const randomOffset = Math.random() * 2;

        const tx = Math.cos(angle) * (radiusAtY + randomOffset);
        const tz = Math.sin(angle) * (radiusAtY + randomOffset);
        const ty = y - CONFIG.treeHeight / 2;

        positions.push(tx, ty, tz);
        originalPos.push(tx, ty, tz);

        const range = 100;
        const sx = (Math.random() - 0.5) * range;
        const sy = (Math.random() - 0.5) * range;
        const sz = (Math.random() - 0.5) * range;
        scatteredPos.push(sx, sy, sz);

        const rand = Math.random();
        let hex;
        if (rand > 0.95) hex = CONFIG.colors[0];
        else if (rand > 0.9) hex = CONFIG.colors[1];
        else hex = CONFIG.colors[2];
        
        colorObj.setHex(hex);
        colors.push(colorObj.r, colorObj.g, colorObj.b);
        sizes.push(Math.random() * 0.5 + 0.1);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
    geometry.setAttribute('aScatter', new THREE.Float32BufferAttribute(scatteredPos, 3));
    geometry.setAttribute('aOriginal', new THREE.Float32BufferAttribute(originalPos, 3));

    const material = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            pointTexture: { value: new THREE.TextureLoader().load('https://assets.codepen.io/127738/dotTexture.png') },
            mixVal: { value: 0.0 }
        },
        vertexShader: `
            attribute float size;
            attribute vec3 color;
            attribute vec3 aScatter;
            attribute vec3 aOriginal;
            varying vec3 vColor;
            uniform float time;
            uniform float mixVal;
            void main() {
                vColor = color;
                vec3 pos = mix(aOriginal, aScatter, mixVal);
                float pulse = sin(time * 3.0 + pos.y * 0.1) * 0.2 + 1.0;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = size * pulse * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
                gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                if (gl_FragColor.a < 0.5) discard;
            }
        `,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        transparent: true
    });

    treeSystem = new THREE.Points(geometry, material);
    scene.add(treeSystem);
}

function createSnow() {
    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    for (let i = 0; i < 2000; i++) {
        vertices.push(
            Math.random() * 200 - 100,
            Math.random() * 200 - 100,
            Math.random() * 200 - 100
        );
    }
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    const material = new THREE.PointsMaterial({
        color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
    });
    snowSystem = new THREE.Points(geometry, material);
    scene.add(snowSystem);
}

/**
 * 3. ç…§ç‰‡ç³»ç»Ÿ
 */
document.getElementById('file-input').addEventListener('change', handleImageUpload);

function handleImageUpload(event) {
    const files = event.target.files;
    if(!files.length) return;
    for (let i = 0; i < Math.min(files.length, 20); i++) {
        const reader = new FileReader();
        reader.onload = function(e) { createPolaroid(e.target.result); };
        reader.readAsDataURL(files[i]);
    }
}

function createPolaroid(imgUrl) {
    const loader = new THREE.TextureLoader();
    loader.load(imgUrl, (texture) => {
        const group = new THREE.Group();
        
        // å¢åŠ  Frame çš„åšåº¦å’Œç»†èŠ‚ï¼Œæ–¹ä¾¿å°„çº¿æ£€æµ‹
        const frameGeo = new THREE.BoxGeometry(6, 7, 0.1); 
        const frameMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        
        const photoGeo = new THREE.PlaneGeometry(5, 5);
        const photoMat = new THREE.MeshBasicMaterial({ map: texture });
        const photo = new THREE.Mesh(photoGeo, photoMat);
        photo.position.z = 0.06;
        photo.position.y = 0.5;
        
        group.add(frame);
        group.add(photo);

        const y = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
        const radius = (CONFIG.treeHeight/2 - y) / CONFIG.treeHeight * CONFIG.treeRadius * 1.2;
        const angle = Math.random() * Math.PI * 2;
        
        group.userData = {
            treePos: new THREE.Vector3(Math.cos(angle)*radius, y, Math.sin(angle)*radius),
            treeRot: new THREE.Euler(0, -angle, 0),
            scatterPos: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80),
            scatterRot: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0),
            originalScale: new THREE.Vector3(1, 1, 1)
        };

        group.position.copy(group.userData.treePos);
        group.rotation.copy(group.userData.treeRot);
        group.lookAt(0, y, 0);

        scene.add(group);
        photos.push(frame); // é‡ç‚¹ï¼šæˆ‘ä»¬å°†frameä½œä¸ºå°„çº¿æ£€æµ‹ç›®æ ‡ï¼Œå› ä¸ºå®ƒæ˜¯Groupä¸­æœ€å¤§çš„å®ä½“
        frame.parentGroup = group; // åå‘å¼•ç”¨

        gsap.from(group.scale, { x: 0, y: 0, z: 0, duration: 1, ease: "elastic.out(1, 0.3)" });
    });
}

/**
 * 4. MediaPipe æ‰‹åŠ¿ä¸å¹³æ»‘é€»è¾‘
 */
function setupMediaPipe() {
    const video = document.getElementById('video-preview');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.5
    });
    
    hands.onResults(onHandsResults);
    
    const cameraUtils = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: 320, height: 240
    });
    cameraUtils.start();
}

// ç®€å•çš„çº¿æ€§æ’å€¼å‡½æ•°ï¼Œç”¨äºå¹³æ»‘ç§»åŠ¨
function lerp(start, end, amt) {
    return (1 - amt) * start + amt * end;
}

function onHandsResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        STATE.handDetected = true;
        const landmarks = results.multiHandLandmarks[0];
        
        // 1. æ›´æ–°æ‰‹åŠ¿å…‰æ ‡ä½ç½® (å¸¦å¹³æ»‘)
        updateHandCursor(landmarks);
        
        // 2. è¯†åˆ«æ‰‹åŠ¿
        const gesture = detectGesture(landmarks);
        updateStateByGesture(gesture);

        // 3. æ—‹è½¬æ§åˆ¶ (å½“ä¸åœ¨æŠ“å–æ—¶)
        if (STATE.current === 'SCATTER' && gesture !== 'PINCH' && STATE.current !== 'FOCUS') {
            handleRotation(landmarks);
        }

    } else {
        STATE.handDetected = false;
        // å¦‚æœæ²¡æœ‰æ‰‹ï¼Œå…‰æ ‡ç§»å‡ºå±å¹•
        mouse.set(-999, -999); 
        cursorDiv.style.opacity = '0';
        STATE.targetRotationY += 0.002;
    }
}

function updateHandCursor(landmarks) {
    // ä½¿ç”¨é£ŸæŒ‡æŒ‡å°– (Index Tip: 8)
    const indexTip = landmarks[8];
    
    // MediaPipe åæ ‡ (0-1). Xè½´éœ€è¦ç¿»è½¬ï¼Œå› ä¸ºæ˜¯é•œåƒ
    const targetX = (1 - indexTip.x) * 2 - 1; 
    const targetY = - (indexTip.y * 2 - 1); 
    
    // åˆå§‹åŒ–
    if (mouse.x === -999) {
        mouse.set(targetX, targetY);
    }
    
    // å¹³æ»‘æ’å€¼ (0.2 çš„ç³»æ•°å†³å®šå»¶è¿Ÿæ„Ÿï¼Œè¶Šå°è¶Šå¹³æ»‘ä½†å»¶è¿Ÿè¶Šé«˜)
    mouse.x = lerp(mouse.x, targetX, 0.2);
    mouse.y = lerp(mouse.y, targetY, 0.2);
    
    // æ›´æ–° HTML ç²¾çµæ¸¸æ ‡ä½ç½®
    const screenX = (mouse.x * .5 + .5) * window.innerWidth;
    const screenY = (mouse.y * -.5 + .5) * window.innerHeight;
    
    cursorDiv.style.transform = `translate(${screenX}px, ${screenY}px)`;
    cursorDiv.style.opacity = '1';
}

function detectGesture(landmarks) {
    const thumbTip = landmarks[4];
    const indexTip = landmarks[8];
    const middleTip = landmarks[12];
    const ringTip = landmarks[16];
    const pinkyTip = landmarks[20];
    const wrist = landmarks[0];

    const fingersOpen = [indexTip, middleTip, ringTip, pinkyTip].every(tip => distance(tip, wrist) > 0.3);
    const pinchDist = distance(thumbTip, indexTip);
    
    const isFist = [indexTip, middleTip, ringTip, pinkyTip].every(tip => distance(tip, wrist) < 0.25);

    // å®½æ¾çš„æåˆåˆ¤å®š (0.08)
    if (pinchDist < 0.08) return 'PINCH';
    if (isFist) return 'FIST';
    if (fingersOpen) return 'OPEN';
    
    return 'UNKNOWN';
}

function distance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

function updateStateByGesture(gesture) {
    const statusText = document.getElementById('state-text');
    
    if (gesture === 'PINCH') {
        cursorDiv.classList.add('grabbing');
        if (STATE.hoveredPhoto && STATE.current === 'SCATTER') {
            // åªæœ‰å½“å‰æœ‰æ‚¬åœç›®æ ‡æ—¶ï¼Œæåˆæ‰ç”Ÿæ•ˆ
            const targetGroup = STATE.hoveredPhoto.parentGroup;
            if (targetGroup !== STATE.focusedPhoto) {
                transitionToFocus(targetGroup);
            }
        }
    } else {
        cursorDiv.classList.remove('grabbing');
        
        if (gesture === 'FIST' && STATE.current !== 'TREE') {
            transitionToTree();
            statusText.innerText = "TREE (MERGED)";
        } 
        else if (gesture === 'OPEN' && STATE.current !== 'SCATTER') {
            transitionToScatter();
            statusText.innerText = "SCATTER (FLOATING)";
        }
    }
}

/**
 * 5. äº¤äº’é€»è¾‘ (Hover ä¸ Focus)
 */
function checkHover() {
    if (STATE.current !== 'SCATTER' || !STATE.handDetected) {
        if (STATE.hoveredPhoto) clearHover();
        return;
    }

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(photos);

    if (intersects.length > 0) {
        const hitObj = intersects[0].object;
        if (STATE.hoveredPhoto !== hitObj) {
            clearHover();
            STATE.hoveredPhoto = hitObj;
            
            // Hover è§†è§‰åé¦ˆï¼šå˜çº¢ + ç¨å¾®å˜å¤§
            gsap.to(hitObj.material.color, { r: 1, g: 0.2, b: 0.2, duration: 0.3 });
            gsap.to(hitObj.parentGroup.scale, { x: 1.2, y: 1.2, z: 1.2, duration: 0.3 });
        }
    } else {
        clearHover();
    }
}

function clearHover() {
    if (STATE.hoveredPhoto) {
        // æ¢å¤ç™½è‰²
        gsap.to(STATE.hoveredPhoto.material.color, { r: 1, g: 1, b: 1, duration: 0.3 });
        // æ¢å¤åŸå§‹å¤§å° (é™¤éå®ƒæ˜¯å½“å‰Focusçš„å¯¹è±¡)
        if (STATE.hoveredPhoto.parentGroup !== STATE.focusedPhoto) {
             gsap.to(STATE.hoveredPhoto.parentGroup.scale, { x: 1, y: 1, z: 1, duration: 0.3 });
        }
        STATE.hoveredPhoto = null;
    }
}

function transitionToTree() {
    STATE.current = 'TREE';
    resetFocus();
    gsap.to(treeSystem.material.uniforms.mixVal, { value: 0.0, duration: 2, ease: "power2.inOut" });
    photos.forEach(mesh => {
        const p = mesh.parentGroup;
        gsap.to(p.position, { x: p.userData.treePos.x, y: p.userData.treePos.y, z: p.userData.treePos.z, duration: 1.5, ease: "power2.inOut" });
        gsap.to(p.rotation, { x: p.userData.treeRot.x, y: p.userData.treeRot.y, z: p.userData.treeRot.z, duration: 1.5 });
        p.lookAt(0, p.position.y, 0); 
    });
    gsap.to(camera.position, { x: 0, y: 20, z: 80, duration: 2 });
}

function transitionToScatter() {
    STATE.current = 'SCATTER';
    resetFocus();
    gsap.to(treeSystem.material.uniforms.mixVal, { value: 1.0, duration: 2, ease: "power2.out" });
    photos.forEach(mesh => {
        const p = mesh.parentGroup;
        gsap.to(p.position, { x: p.userData.scatterPos.x, y: p.userData.scatterPos.y, z: p.userData.scatterPos.z, duration: 2, ease: "power2.out" });
        gsap.to(p.rotation, { x: p.userData.scatterRot.x, y: p.userData.scatterRot.y, z: p.userData.scatterRot.z, duration: 2 });
    });
}

function transitionToFocus(photoGroup) {
    STATE.current = 'FOCUS';
    STATE.focusedPhoto = photoGroup;
    document.getElementById('state-text').innerText = "FOCUS (MEMORY)";

    const targetPos = new THREE.Vector3(0, 0, -15); 
    targetPos.applyMatrix4(camera.matrixWorld);

    gsap.to(photoGroup.position, {
        x: targetPos.x, y: targetPos.y, z: targetPos.z,
        duration: 1, ease: "power3.out",
        onUpdate: () => photoGroup.lookAt(camera.position)
    });
    gsap.to(photoGroup.scale, { x: 4, y: 4, z: 4, duration: 1 });
}

function resetFocus() {
    if(STATE.focusedPhoto) {
        gsap.to(STATE.focusedPhoto.scale, {x:1, y:1, z:1, duration: 0.5});
        STATE.focusedPhoto = null;
    }
}

function handleRotation(landmarks) {
    const x = landmarks[9].x; 
    const targetAngle = (x - 0.5) * 4; 
    STATE.targetRotationY += (targetAngle - STATE.targetRotationY) * 0.05;
}

/**
 * æ¸²æŸ“å¾ªç¯
 */
function animate() {
    requestAnimationFrame(animate);
    const time = performance.now() * 0.001;
    
    if(treeSystem) treeSystem.material.uniforms.time.value = time;
    
    if(snowSystem) {
        const positions = snowSystem.geometry.attributes.position.array;
        for(let i=1; i<positions.length; i+=3) {
            positions[i] -= 0.2;
            if(positions[i] < -50) positions[i] = 100;
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;
    }

    // å®æ—¶æ£€æµ‹æ‚¬åœ (Hover)
    checkHover();

    if (STATE.current !== 'FOCUS') {
        const currentRot = scene.rotation.y;
        scene.rotation.y += (STATE.targetRotationY - currentRot) * 0.05;
        if(!STATE.handDetected && STATE.current === 'TREE') {
             scene.rotation.y += 0.002;
             STATE.targetRotationY = scene.rotation.y;
        }
    }

    // æ¼‚æµ®åŠ¨ç”»
    if (STATE.current === 'SCATTER') {
        photos.forEach((mesh, i) => {
            const p = mesh.parentGroup;
            if(p !== STATE.focusedPhoto) {
                p.position.y += Math.sin(time + i) * 0.02;
            }
        });
    }

    composer.render();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

window.onload = function() {
    initThree();
    setupMediaPipe();
    animate();
};
</script>
</body>
</html>
