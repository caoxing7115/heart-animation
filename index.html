<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Magic Gesture Christmas Tree â€” Full</title>
  <style>
    :root{
      --matte-green: #183b2c;
      --metal-gold: #caa43a;
      --christmas-red: #a61f2a;
      --bg-dark: #050607;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;background: radial-gradient(circle at 10% 10%, rgba(39,67,47,0.06), transparent 15%), linear-gradient(180deg,#020404 0%, #040709 60%); font-family: Inter, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    #canvas-container{position:fixed;inset:0;z-index:1;overflow:hidden;}
    /* UI */
    #ui{position:fixed;right:18px;top:18px;z-index:40;display:flex;flex-direction:column;gap:10px}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.07)); border:1px solid rgba(255,255,255,0.04); padding:12px; border-radius:12px; color:#eee; width:240px; box-shadow:0 8px 30px rgba(0,0,0,0.6)}
    .panel h3{margin:0 0 8px 0;color:var(--metal-gold); font-size:14px}
    .btn{display:inline-block;padding:8px 10px;border-radius:8px;border:1px solid var(--metal-gold); background:rgba(11,59,36,0.75); color:#fff; cursor:pointer; font-weight:600; font-size:13px}
    .btn:hover{background:var(--metal-gold); color:#111}
    .small{font-size:12px;color:#ccc}
    #status{font-size:12px;color:#cfcfcf;margin-top:8px}
    /* camera preview (hidden by default) */
    #preview{position:fixed;left:18px;top:18px;width:160px;height:120px;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.04);display:none;z-index:30;box-shadow:0 8px 26px rgba(0,0,0,0.6)}
    #preview video{width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
    /* hint bottom */
    #hint{position:fixed;left:18px;bottom:18px;color:#ddd;font-size:13px;text-shadow:0 2px 12px rgba(0,0,0,0.7);z-index:40;background:rgba(0,0,0,0.28);padding:8px 12px;border-radius:10px;border-left:3px solid var(--metal-gold)}
    /* loader */
    #loader{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(2,3,2,0.88), rgba(2,3,2,0.95));color:var(--metal-gold);font-weight:700;letter-spacing:6px;z-index:100}
    a.link{color:var(--metal-gold)}
  </style>

  <!-- MediaPipe (éæ¨¡å—æ–¹å¼) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <!-- Three.js ä½œä¸º module åœ¨ä¸‹é¢çš„ script ä¸­å¯¼å…¥ -->
  <!-- GSAP -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="ui">
    <div class="panel">
      <h3>Gesture Tree Â· æ§åˆ¶é¢æ¿</h3>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="btnConverge" class="btn">åˆæ‹¢ï¼ˆTreeï¼‰</button>
        <button id="btnScatter" class="btn">æ•£å¼€ï¼ˆScatterï¼‰</button>
        <button id="btnReset" class="btn">é‡ç½®è§†è§’</button>
      </div>
      <div style="margin-top:8px">
        <input id="photoUpload" type="file" accept="image/*" multiple style="display:none">
        <button id="uploadBtn" class="btn" style="margin-top:8px">ä¸Šä¼ ç…§ç‰‡</button>
        <div id="status" class="small">çŠ¶æ€: åˆå§‹åŒ–...</div>
      </div>
    </div>

    <div class="panel">
      <div class="small">æ‰‹åŠ¿:</div>
      <ul class="small" style="margin:8px 0 0 16px;padding:0">
        <li>âœŠ æ¡æ‹³ â†’ åˆæ‹¢</li>
        <li>ğŸ– å¼ å¼€ â†’ æ•£å¼€</li>
        <li>ğŸ¤ æåˆï¼ˆæ‹‡æŒ‡+é£ŸæŒ‡é è¿‘ï¼‰â†’ æŠ“å–å¹¶æ”¾å¤§ç…§ç‰‡</li>
        <li>âœ‹ åœ¨æ•£å¼€æ€ç§»åŠ¨æ‰‹æŒ â†’ æ—‹è½¬è§†è§’</li>
      </ul>
      <div style="margin-top:8px" class="small">æç¤º: ç›¸æœºéœ€è¦æˆæƒï¼›åœ¨ä½å…‰ä¸‹è¯·æé«˜ç¯å¢ƒå…‰</div>
    </div>
  </div>

  <div id="preview"><video id="videoPreview" autoplay muted playsinline></video></div>
  <div id="hint">Gesture Tree å·²å°±ç»ª â€” ä¸Šä¼ ç…§ç‰‡åç”¨æ‰‹åŠ¿æ§åˆ¶ï¼</div>
  <div id="loader">LOADING... PLEASE ALLOW CAMERA</div>

  <script type="module">
  /* ================================
     Full application code (module)
     - Three.js imports
     ================================ */
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';
  import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';

  // -----------------------
  // å…¨å±€é…ç½®ä¸çŠ¶æ€
  // -----------------------
  const STATE = { CONVERGE: 'converge', SCATTER: 'scatter', PHOTO: 'photo' };
  let appState = STATE.CONVERGE;
  let activePhoto = null;

  const MAX_PHOTOS = 12;

  // UI elements
  const loaderEl = document.getElementById('loader');
  const statusEl = document.getElementById('status');
  const previewEl = document.getElementById('preview');
  const previewVid = document.getElementById('videoPreview');
  const hint = document.getElementById('hint');

  // æ‘„åƒå¤´ video hidden for mediapipe
  const hiddenVideo = document.createElement('video');
  hiddenVideo.setAttribute('playsinline', '');
  hiddenVideo.muted = true;
  hiddenVideo.style.display = 'none';
  document.body.appendChild(hiddenVideo);

  // Three.js: åœºæ™¯ã€ç›¸æœºã€æ¸²æŸ“å™¨
  const container = document.getElementById('canvas-container');
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x020408, 0.0025);

  const camera = new THREE.PerspectiveCamera(48, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0, 18, 60);
  camera.lookAt(0, 6, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  // small orbit controls for reset convenience (disabled)
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enabled = false;

  // åæœŸï¼šBloom
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.6, 0.6, 0.9);
  bloom.threshold = 0.08;
  bloom.strength = 1.2;
  bloom.radius = 0.6;
  composer.addPass(bloom);

  // -----------------------
  // ç¯å¢ƒå…‰ä¸ä¸»ç¯å…‰ï¼šæ‰“é€ é‡‘ç¢§è¾‰ç…Œçš„é«˜çº§æ„Ÿ
  // -----------------------
  const hemi = new THREE.HemisphereLight(0x664433, 0x0b0b10, 0.25);
  scene.add(hemi);

  const key = new THREE.PointLight(0xffe6b3, 1.6, 200);
  key.position.set(40, 40, 30);
  scene.add(key);

  const rim = new THREE.SpotLight(0xff8a8a, 1.2, 200, Math.PI/6, 0.3, 2);
  rim.position.set(-30, 20, -30);
  rim.target.position.set(0, 10, 0);
  scene.add(rim);
  scene.add(rim.target);

  const topLight = new THREE.SpotLight(0xffffff, 1.2, 500, Math.PI/5, 0.6, 2);
  topLight.position.set(0, 120, 10);
  topLight.target.position.set(0, 10, 0);
  scene.add(topLight);
  scene.add(topLight.target);

  // è½»å¾®åœ°é¢
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(600,600), new THREE.MeshStandardMaterial({
    color: 0x030706, roughness: 1.0, metalness: 0.0
  }));
  ground.rotateX(-Math.PI/2);
  ground.position.y = -24;
  ground.receiveShadow = true;
  scene.add(ground);

  // -----------------------
  // å‡ ä½•ä¸åŸºç¡€æè´¨ï¼ˆå¤ç”¨ï¼‰
  // -----------------------
  const geos = {
    sphere: new THREE.SphereGeometry(0.8, 24, 24),
    box: new THREE.BoxGeometry(1.4, 1.4, 1.4),
    cane: new THREE.CylinderGeometry(0.18, 0.18, 3.2, 16),
    plane: new THREE.PlaneGeometry(3.0, 3.0)
  };

  const matGreen = new THREE.MeshStandardMaterial({ color: 0x1b5a3e, roughness:0.85, metalness: 0.03 });
  const matGold = new THREE.MeshStandardMaterial({ color: 0xD9B24D, roughness:0.2, metalness: 1.0, emissive: 0x261803, emissiveIntensity: 0.2 });
  const matRed = new THREE.MeshStandardMaterial({ color: 0xA61F2A, roughness:0.35, metalness: 0.3 });
  const matSilver = new THREE.MeshStandardMaterial({ color: 0xE6E9EE, roughness:0.15, metalness: 0.9 });

  // -----------------------
  // åœºæ™¯å¯¹è±¡ç®¡ç†
  // -----------------------
  const objects = []; // { mesh, type, treePos, scatterPos, baseScale }

  // uploaded textures
  const uploadedTextures = [];

  // -----------------------
  // ç¾åŒ–åçš„ createSceneElementsï¼ˆå®Œæ•´æ›¿æ¢ï¼‰
  // -----------------------
  function createSceneElements() {
    // æ¸…ç†
    objects.forEach(o => scene.remove(o.mesh));
    objects.length = 0;

    const particleCount = 380;
    const treeHeight = 44;
    const maxRadius = 16;

    // blink bulbs material
    const bulbGeo = new THREE.SphereGeometry(0.45, 12, 12);

    for (let i = 0; i < particleCount; i++) {
      let mesh, type = 'deco';
      const r = Math.random();
      const t = i / particleCount;
      const y = t * treeHeight - treeHeight / 2; // -h/2 .. h/2
      const level = 1 - t;
      const radius = maxRadius * Math.pow(level, 1.15) * (0.8 + Math.random() * 0.35);
      const theta = i * 0.25 + Math.random() * 0.9;

      const treePos = new THREE.Vector3(
        radius * Math.cos(theta),
        y,
        radius * Math.sin(theta)
      );

      // æ•£å¼€ä½ç½®
      const scatterPos = new THREE.Vector3(
        (Math.random() - 0.5) * 90,
        (Math.random() - 0.2) * 90,
        (Math.random() - 0.5) * 90
      );

      // å†³å®šç±»å‹ï¼šä¼˜å…ˆåˆ†é…ç…§ç‰‡
      if (uploadedTextures.length > 0 && r < 0.14) {
        type = 'photo';
        const tex = uploadedTextures[Math.floor(Math.random() * uploadedTextures.length)];
        const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
        mesh = new THREE.Mesh(geos.plane, mat);
        // æ ¹æ®è´´å›¾å®½é«˜æ¯”ç¼©æ”¾
        if (tex.image) {
          const asp = tex.image.width / Math.max(1, tex.image.height);
          mesh.scale.set(1.8 * asp, 1.8, 1);
        } else {
          mesh.scale.set(1.8, 1.8, 1);
        }
      } else if (r < 0.28) {
        mesh = new THREE.Mesh(geos.box, matGold);
      } else if (r < 0.42) {
        const pal = [0xE60026, 0x0040FF, 0xFFFFFF, 0xFFD700];
        const clr = pal[Math.floor(Math.random() * pal.length)];
        mesh = new THREE.Mesh(geos.sphere, new THREE.MeshStandardMaterial({ color: clr, metalness: 0.85, roughness: 0.2 }));
      } else if (r < 0.52) {
        mesh = new THREE.Mesh(geos.cane, matRed);
        mesh.rotation.z = Math.random() * Math.PI;
      } else {
        // simulate little green filler balls as leaves decoration
        const depthShade = 30 + Math.random() * 20;
        mesh = new THREE.Mesh(geos.sphere, new THREE.MeshStandardMaterial({
          color: new THREE.Color(`hsl(130,37%,${depthShade}%)`),
          roughness: 0.85,
          metalness: 0.02
        }));
      }

      mesh.position.copy(treePos);
      mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      scene.add(mesh);

      objects.push({
        mesh,
        type,
        treePos: treePos.clone(),
        scatterPos: scatterPos.clone(),
        baseScale: mesh.scale.clone()
      });

      // å°‘é‡é—ªçƒå°ç¯æ³¡ï¼ˆ15%æ¦‚ç‡ï¼‰
      if (Math.random() < 0.15) {
        const bulbMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffe6b3, emissiveIntensity: 1.2, metalness: 0.0, roughness: 0.3 });
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        bulb.position.copy(treePos.clone().add(new THREE.Vector3((Math.random()-0.5)*0.6, (Math.random()-0.5)*0.6, (Math.random()-0.5)*0.6)));
        scene.add(bulb);

        // animate blink
        gsap.to(bulb.material, {
          emissiveIntensity: 0.2 + Math.random() * 1.6,
          duration: 0.6 + Math.random() * 1.2,
          repeat: -1, yoyo: true, ease: "sine.inOut"
        });

        objects.push({
          mesh: bulb,
          type: 'bulb',
          treePos: bulb.position.clone(),
          scatterPos: new THREE.Vector3((Math.random()-0.5)*90, (Math.random()-0.5)*90, (Math.random()-0.5)*90),
          baseScale: bulb.scale.clone()
        });
      }
    }

    // æ ‘é¡¶æ˜Ÿ
    const starGeo = new THREE.IcosahedronGeometry(3.4, 0);
    const starMat = new THREE.MeshStandardMaterial({ color: 0xFFF8E6, emissive: 0xFFD96B, emissiveIntensity: 3.2, metalness: 1.0, roughness: 0.05 });
    const star = new THREE.Mesh(starGeo, starMat);
    star.position.set(0, treeHeight/2 + 3.2, 0);
    star.castShadow = true;
    scene.add(star);

    gsap.to(star.rotation, { y: "+=6.28", duration: 12, repeat: -1, ease: "none" });
    objects.push({ mesh: star, type: 'star', treePos: star.position.clone(), scatterPos: new THREE.Vector3(0, 40, 0), baseScale: star.scale.clone() });

    // subtle light around tree center (point)
    const centerLight = new THREE.PointLight(0xffeab0, 0.65, 120);
    centerLight.position.set(0, 8, 0);
    scene.add(centerLight);
  }

  // init
  createSceneElements();
  loaderEl.style.opacity = "0";
  setTimeout(()=>loaderEl.style.display = "none", 600);

  // -----------------------
  // é›ªèŠ±ç²’å­ç³»ç»Ÿï¼ˆè½»å¾®é£˜è½ï¼‰
  // -----------------------
  const snowCount = 260;
  const snowGeo = new THREE.BufferGeometry();
  const snowPos = new Float32Array(snowCount * 3);
  for (let i = 0; i < snowCount; i++) {
    snowPos[i*3+0] = (Math.random()-0.5) * 260;
    snowPos[i*3+1] = Math.random() * 160 + 10;
    snowPos[i*3+2] = (Math.random()-0.5) * 260;
  }
  snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
  const snowMat = new THREE.PointsMaterial({ size: 0.6, color: 0xffffff, transparent: true, opacity: 0.85 });
  const snow = new THREE.Points(snowGeo, snowMat);
  scene.add(snow);

  // -----------------------
  // çŠ¶æ€è½¬æ¢å‡½æ•°ï¼ˆä½¿ç”¨ GSAP å¹³æ»‘è¿‡æ¸¡ï¼‰
  // -----------------------
  function setState(newState, data = {}) {
    if (appState === newState && newState !== STATE.PHOTO) return;
    appState = newState;
    statusEl.textContent = `çŠ¶æ€: ${newState.toUpperCase()}`;

    if (newState === STATE.CONVERGE) {
      // æ‰€æœ‰å¯¹è±¡å›åˆ° treePos
      objects.forEach((o, idx) => {
        gsap.to(o.mesh.position, { x: o.treePos.x, y: o.treePos.y, z: o.treePos.z, duration: 1.2 + Math.random()*0.6, ease: "elastic.out(1,0.8)" });
        gsap.to(o.mesh.rotation, { x: Math.random()*3, y: Math.random()*3, z: Math.random()*3, duration: 1.0 + Math.random()*0.4, ease: "power2.out" });
        gsap.to(o.mesh.scale, { x: o.baseScale.x, y: o.baseScale.y, z: o.baseScale.z, duration: 0.8, ease: "back.out(1.4)" });
      });
      // subtle overall spin
      gsap.to(scene.rotation, { y: 0, x: 0, duration: 1.6, ease: "power2.out" });
    }
    else if (newState === STATE.SCATTER) {
      objects.forEach((o, idx) => {
        const sp = o.scatterPos;
        gsap.to(o.mesh.position, { x: sp.x, y: sp.y, z: sp.z, duration: 1.4 + Math.random()*0.9, ease: "power2.out" });
        gsap.to(o.mesh.rotation, { x: o.scatterRot ? o.scatterRot.x : Math.random()*3, y: o.scatterRot ? o.scatterRot.y : Math.random()*3, z: 0, duration: 1.8, ease: "power2.out" });
        gsap.to(o.mesh.scale, { x: o.baseScale.x * 0.8, y: o.baseScale.y * 0.8, z: o.baseScale.z * 0.8, duration: 1.2, ease: "power1.out" });
      });
    }
    else if (newState === STATE.PHOTO) {
      // æ”¾å¤§æŸå¼ ç…§ç‰‡ï¼ˆdata.targetï¼‰
      const target = data.target;
      if (!target) return;
      activePhoto = target;
      objects.forEach(o => {
        if (o.mesh === target.mesh) {
          // bring near camera: compute a point slightly in front of camera
          const front = new THREE.Vector3(0, 6, -18).applyMatrix4(camera.matrixWorld);
          gsap.to(o.mesh.position, { x: front.x, y: front.y, z: front.z, duration: 1.1, ease: "expo.out" });
          gsap.to(o.mesh.scale, { x: o.baseScale.x * 3.6, y: o.baseScale.y * 3.6, z: o.baseScale.z * 3.6, duration: 1.1, ease: "expo.out" });
          gsap.to(o.mesh.rotation, { x: 0, y: 0, z: 0, duration: 0.8, ease: "power2.out" });
        } else {
          // push others away and shrink
          const pushed = o.scatterPos.clone().multiplyScalar(1.2 + Math.random()*0.6);
          gsap.to(o.mesh.position, { x: pushed.x, y: pushed.y, z: pushed.z, duration: 1.2, ease: "power2.inOut" });
          gsap.to(o.mesh.scale, { x: o.baseScale.x*0.5, y: o.baseScale.y*0.5, z: o.baseScale.z*0.5, duration: 0.9, ease: "power2.inOut" });
        }
      });
    }
  }

  // -----------------------
  // ç…§ç‰‡ä¸Šä¼ å¤„ç†
  // -----------------------
  const fileInput = document.getElementById('photoUpload');
  document.getElementById('uploadBtn').addEventListener('click', ()=> fileInput.click());
  fileInput.addEventListener('change', (ev) => {
    const files = Array.from(ev.target.files).slice(0, MAX_PHOTOS);
    if (files.length === 0) return;
    uploadedTextures.length = 0;
    let loaded = 0;
    files.forEach((f, idx) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.src = e.target.result;
        img.onload = () => {
          const tex = new THREE.Texture(img);
          tex.needsUpdate = true;
          tex.image = img;
          uploadedTextures.push(tex);
          loaded++;
          if (loaded === files.length) {
            // rebuild scene with photos
            createSceneElements();
            hint.textContent = `å·²ä¸Šä¼  ${files.length} å¼ ç…§ç‰‡ï¼Œå‡†å¤‡å°±ç»ª`;
          }
        };
      };
      reader.readAsDataURL(f);
    });
    fileInput.value = "";
  });

  // -----------------------
  // é¼ æ ‡ / è§¦æ‘¸äº¤äº’ï¼šç‚¹å‡»æ”¾å¤§ç…§ç‰‡ï¼ˆå¯é€‰ï¼‰
  // -----------------------
  const ray = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  renderer.domElement.addEventListener('pointerdown', (e) => {
    pointer.x = ( e.clientX / window.innerWidth ) * 2 - 1;
    pointer.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
    ray.setFromCamera(pointer, camera);
    const meshes = objects.map(o => o.mesh);
    const hits = ray.intersectObjects(meshes, true);
    if (hits.length > 0) {
      const hit = hits[0].object;
      const obj = objects.find(o => o.mesh === hit || o.mesh.children?.includes(hit));
      if (obj && obj.type === 'photo') {
        setState(STATE.PHOTO, { target: obj });
      } else {
        // ç‚¹å‡»ç©ºç™½æˆ–éç…§ç‰‡æ—¶ï¼šå¦‚æœå¤„äº PHOTO æ¨¡å¼ï¼Œåˆ™å›åˆ°æ•£å¼€æ€
        if (appState === STATE.PHOTO) setState(STATE.SCATTER);
      }
    } else {
      if (appState === STATE.PHOTO) setState(STATE.SCATTER);
      else setState(STATE.SCATTER);
    }
  });

  // -----------------------
  // MediaPipe Hands é›†æˆï¼ˆæ‰‹åŠ¿è¯†åˆ«ï¼‰
  // -----------------------
  const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
  hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.6 });

  let lastAngle = null;
  let handInFrame = false;
  let lastHandX = null;

  hands.onResults((results) => {
    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
      handInFrame = false;
      // small timeout? no action
      return;
    }
    handInFrame = true;
    const lm = results.multiHandLandmarks[0];

    // ç®€å•æ‰‹æŒ‡ä¼¸å±•åˆ¤æ–­ï¼ˆç”¨ tip åˆ° wrist è·ç¦»ï¼‰
    function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y, (a.z||0)-(b.z||0)); }
    const wrist = lm[0];
    const tips = [4,8,12,16,20];
    let extended = 0;
    for (let i=0;i<tips.length;i++){
      const id = tips[i];
      if (dist(lm[id], wrist) > 0.08 + 0.02*(0.05/dist(lm[9], wrist))) extended++;
    }

    // æ£€æµ‹æ¡æ‹³ï¼ˆextended <=1ï¼‰
    if (extended <= 1) {
      setState(STATE.CONVERGE);
      return;
    }

    // äº”æŒ‡å¼ å¼€ï¼ˆ>=4ï¼‰
    if (extended >= 4) {
      if (appState !== STATE.SCATTER) setState(STATE.SCATTER);
      // rotation control: use palm center (landmark 9) and angle between wrist(0) and middle_mcp(9)
      const a = lm[0], b = lm[9];
      const angle = Math.atan2(b.y - a.y, b.x - a.x);
      if (lastAngle == null) lastAngle = angle;
      const d = angle - lastAngle;
      // rotate scene around Y by d scaled
      const rot = d * -2.2;
      scene.rotation.y += rot;
      lastAngle = angle;

      // also map palm x to tilt
      const palmX = lm[9].x;
      const tilt = (palmX - 0.5) * Math.PI * 0.35;
      gsap.to(scene.rotation, { x: tilt, duration: 0.6, ease: "power1.out" });
    }

    // pinch detection (thumb tip 4 to index tip 8)
    const pinchDist = dist(lm[4], lm[8]);
    const pinchThresh = 0.045;
    if (pinchDist < pinchThresh && appState === STATE.SCATTER) {
      // find nearest photo by projecting to screen
      let best = null; let bestD = Infinity;
      objects.forEach(o => {
        if (o.type === 'photo') {
          const pos = o.mesh.position.clone().project(camera);
          const sx = (pos.x * .5 + 0.5) * window.innerWidth;
          const sy = (-pos.y * .5 + 0.5) * window.innerHeight;
          const hx = lm[8].x * window.innerWidth;
          const hy = lm[8].y * window.innerHeight;
          const dpx = Math.hypot(sx-hx, sy-hy);
          if (dpx < bestD){ bestD = dpx; best = o; }
        }
      });
      if (best && bestD < Math.min(window.innerWidth, window.innerHeight) * 0.12) {
        setState(STATE.PHOTO, { target: best }); // æ”¾å¤§é€‰ä¸­çš„ç…§ç‰‡
      }
    }

    // release pinch: if pinch released and in PHOTO mode -> back to scatter
    if (pinchDist > pinchThresh*2 && appState === STATE.PHOTO && !activePhoto === null) {
      // keep as scatter
      // activePhoto = null;
      // setState(STATE.SCATTER);
      // but do not auto revert to avoidé—ªçƒ
    }
  });

  // -----------------------
  // å¯åŠ¨æ‘„åƒå¤´ï¼ˆMediaPipe Camera helperï¼‰
  // -----------------------
  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
      hiddenVideo.srcObject = stream;
      previewVid.srcObject = stream; previewEl.style.display = 'block';
      await hiddenVideo.play();
      await previewVid.play();

      const cameraFeed = new Camera(hiddenVideo, {
        onFrame: async () => {
          await hands.send({ image: hiddenVideo });
        },
        width: 640, height: 480
      });
      cameraFeed.start();
      statusEl.textContent = 'çŠ¶æ€: æ‘„åƒå¤´å·²å¯ç”¨ï¼Œè¯†åˆ«å°±ç»ª';
      hint.textContent = 'æ‰‹åŠ¿è¯†åˆ«å·²å¯ç”¨ï¼šæ¡æ‹³-åˆæ‹¢ã€å¼ å¼€-æ•£å¼€ã€æåˆ-æ”¾å¤§ç…§ç‰‡';
    } catch (e) {
      statusEl.textContent = 'çŠ¶æ€: æ‘„åƒå¤´æƒé™è¢«æ‹’ç»æˆ–ä¸å¯ç”¨';
      loaderEl.style.display = 'none';
      alert('è¯·åœ¨ HTTPS æˆ– localhost ä¸‹æ‰“å¼€é¡µé¢å¹¶å…è®¸æ‘„åƒå¤´æƒé™ã€‚\né”™è¯¯: ' + e.message);
    }
  }
  startCamera();

  // -----------------------
  // UI æŒ‰é’®ç»‘å®š
  // -----------------------
  document.getElementById('btnConverge').addEventListener('click', ()=> setState(STATE.CONVERGE));
  document.getElementById('btnScatter').addEventListener('click', ()=> setState(STATE.SCATTER));
  document.getElementById('btnReset').addEventListener('click', ()=> {
    gsap.to(camera.position, { x:0, y:18, z:60, duration:1.2, ease:"power2.out" });
    gsap.to(scene.rotation, { x:0, y:0, duration:1.2, ease:"power2.out" });
  });

  // -----------------------
  // æ¸²æŸ“å¾ªç¯
  // -----------------------
  const clock = new THREE.Clock();
  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    // objects å¾®åŠ¨ï¼ˆidleï¼‰
    if (appState === STATE.SCATTER) {
      objects.forEach((o, i) => {
        o.mesh.position.y += Math.sin(t*0.6 + i) * 0.002;
        o.mesh.rotation.y += 0.002 + (i%3)*0.0008;
      });
    } else if (appState === STATE.CONVERGE) {
      // slow tree rotation
      scene.rotation.y = Math.sin(t*0.08) * 0.18;
    } else if (appState === STATE.PHOTO) {
      // if activePhoto is set, ensure it faces camera
      if (activePhoto) {
        activePhoto.mesh.lookAt(camera.position);
        // smoothly place it at a fixed spot in front of camera
        const targetPos = new THREE.Vector3(0,6,-18).applyMatrix4(camera.matrixWorld);
        gsap.to(activePhoto.mesh.position, { x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 0.5, ease:"power2.out" });
      }
    }

    // snow animation
    const pos = snow.geometry.attributes.position.array;
    for (let i=0;i<snowCount;i++){
      pos[i*3+1] -= 0.03 + Math.sin((t*0.2)+i)*0.01;
      if (pos[i*3+1] < -30) pos[i*3+1] = 150 + Math.random()*40;
    }
    snow.geometry.attributes.position.needsUpdate = true;

    composer.render();
  }
  animate();

  // -----------------------
  // æµè§ˆå™¨äº‹ä»¶ï¼šè°ƒæ•´å¤§å°
  // -----------------------
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  });

  // -----------------------
  // å°ä¼˜åŒ–ï¼šè‡ªåŠ¨å…ˆåˆ‡æ¢åˆ°åˆæ‹¢æ€
  // -----------------------
  setTimeout(()=> setState(STATE.CONVERGE), 600);

  // -----------------------
  // äº¤äº’ï¼šç”¨é”®ç›˜å¿«é€Ÿåˆ‡æ¢ï¼ˆæ–¹ä¾¿æµ‹è¯•ï¼‰
  // -----------------------
  window.addEventListener('keydown', (e) => {
    if (e.key === '1') setState(STATE.CONVERGE);
    if (e.key === '2') setState(STATE.SCATTER);
    if (e.key === '3') {
      const photos = objects.filter(o => o.type === 'photo');
      if (photos.length) setState(STATE.PHOTO, { target: photos[0] });
    }
  });

  // -----------------------
  // æ¸…ç†æç¤º
  // -----------------------
  loaderEl.style.display = 'none';
  statusEl.textContent = 'çŠ¶æ€: å°±ç»ª';
  </script>
</body>
</html>
