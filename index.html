<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lumière Noël</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300;400&display=swap" rel="stylesheet">
    <!-- Babel Standalone for in-browser JSX/TS compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; background-color: #050505; color: #fff; font-family: 'Lato', sans-serif; }
      h1, h2, h3, .cinzel { font-family: 'Cinzel', serif; }
      ::-webkit-scrollbar { width: 6px; }
      ::-webkit-scrollbar-track { background: transparent; }
      ::-webkit-scrollbar-thumb { background: #b8860b; border-radius: 3px; }
      #root { width: 100vw; height: 100vh; }
      
      /* Custom Gold Colors for Tailwind */
      .text-gold-300 { color: #fadd75; }
      .text-gold-400 { color: #facc15; }
      .bg-gold-600 { background-color: #ca8a04; }
      .border-gold-500 { border-color: #eab308; }
    </style>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react/": "https://esm.sh/react@18.2.0/",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "zustand": "https://esm.sh/zustand@4.5.0",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16",
    "uuid": "https://esm.sh/uuid@9.0.1",
    "three": "https://esm.sh/three@0.161.0",
    "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@0.10.9",
    "maath/easing": "https://esm.sh/maath@0.10.7/easing",
    "react-dom/": "https://esm.sh/react-dom@^19.2.1/",
    "maath/": "https://esm.sh/maath@^0.10.8/"
  }
}
</script>
  </head>
  <body>
    <div id="root"></div>

    <!-- Main Application Script (Inlined for Portability) -->
    <script type="text/babel" data-type="module" data-presets="react,typescript">
import React, { useEffect, useRef, useState, useMemo } from 'react';
import { createRoot } from 'react-dom/client';
import { Canvas, useFrame, useThree } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera, Stars } from '@react-three/drei';
import { EffectComposer, Bloom, Vignette, Noise } from '@react-three/postprocessing';
import * as THREE from 'three';
import { Vector3 } from 'three';
import { create } from 'zustand';
import { v4 as uuidv4 } from 'uuid';
import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
import { damp3, damp } from 'maath/easing';

// --- TYPES ---

export enum AppMode {
  TREE = 'TREE',       
  SCATTERED = 'SCATTERED', 
  FOCUSED = 'FOCUSED',   
}

export interface PhotoData {
  id: string;
  url: string;
  position: Vector3; 
  rotation: Vector3;
  scatterPosition: Vector3; 
}

// --- STORE ---

interface AppState {
  mode: AppMode;
  setMode: (mode: AppMode) => void;
  photos: PhotoData[];
  addPhoto: (url: string) => void;
  focusedPhotoId: string | null;
  setFocusedPhotoId: (id: string | null) => void;
  handPosition: { x: number, y: number };
  setHandPosition: (pos: { x: number, y: number }) => void;
  isCameraRotating: boolean;
  setIsCameraRotating: (rotating: boolean) => void;
}

const generateRandomTreePos = () => {
  const height = (Math.random() * 10) - 5; 
  const radius = ((5 - height) / 10) * 3.5; 
  const angle = Math.random() * Math.PI * 2;
  const x = Math.cos(angle) * radius;
  const z = Math.sin(angle) * radius;
  return new Vector3(x, height, z);
};

const generateRandomScatterPos = () => {
  return new Vector3(
    (Math.random() - 0.5) * 15,
    (Math.random() - 0.5) * 15,
    (Math.random() - 0.5) * 15
  );
};

const useStore = create((set) => ({
  mode: AppMode.TREE,
  setMode: (mode) => set({ mode }),
  photos: [],
  addPhoto: (url) => set((state) => {
    const newPhoto = {
      id: uuidv4(),
      url,
      position: generateRandomTreePos(),
      rotation: new Vector3(0, Math.random() * Math.PI * 2, 0),
      scatterPosition: generateRandomScatterPos(),
    };
    return { photos: [...state.photos, newPhoto] };
  }),
  focusedPhotoId: null,
  setFocusedPhotoId: (id) => set({ focusedPhotoId: id }),
  handPosition: { x: 0.5, y: 0.5 },
  setHandPosition: (pos) => set({ handPosition: pos }),
  isCameraRotating: false,
  setIsCameraRotating: (rotating) => set({ isCameraRotating: rotating }),
}));

// Initialize placeholders
const placeholderImages = [
  "https://picsum.photos/400/500?random=1",
  "https://picsum.photos/400/500?random=2",
  "https://picsum.photos/400/500?random=3",
  "https://picsum.photos/400/500?random=4",
  "https://picsum.photos/400/500?random=5",
];
placeholderImages.forEach(url => useStore.getState().addPhoto(url));

// --- COMPONENTS ---

const GestureController = () => {
  const videoRef = useRef(null);
  const [status, setStatus] = useState("init");
  
  const setMode = useStore((state) => state.setMode);
  const currentMode = useStore((state) => state.mode);
  const setHandPosition = useStore((state) => state.setHandPosition);
  const setIsCameraRotating = useStore((state) => state.setIsCameraRotating);

  const lastProcessed = useRef(0);

  useEffect(() => {
    let handLandmarker = null;
    let animationFrameId;

    const setupMediaPipe = async () => {
      try {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
        );
        
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 1
        });

        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
              video: { width: 640, height: 480, facingMode: "user" } 
            });
            if (videoRef.current) {
              videoRef.current.srcObject = stream;
              videoRef.current.onloadeddata = () => {
                setStatus("ready");
                predictWebcam();
              };
            }
          } catch (err) {
            console.warn("Camera permission denied:", err);
            setStatus("denied");
          }
        } else {
           setStatus("error");
        }
      } catch (err) {
        console.error("MediaPipe error:", err);
        setStatus("error");
      }
    };

    const predictWebcam = async () => {
      if (status === 'denied' || status === 'error') return;

      const now = performance.now();
      if (now - lastProcessed.current < 33) {
        animationFrameId = requestAnimationFrame(predictWebcam);
        return;
      }
      lastProcessed.current = now;

      if (handLandmarker && videoRef.current && videoRef.current.readyState >= 2) {
        try {
            const results = handLandmarker.detectForVideo(videoRef.current, now);
            
            if (results.landmarks && results.landmarks.length > 0) {
              const landmarks = results.landmarks[0];
              const wrist = landmarks[0];
              const tips = [landmarks[4], landmarks[8], landmarks[12], landmarks[16], landmarks[20]]; 
              const pips = [landmarks[2], landmarks[6], landmarks[10], landmarks[14], landmarks[18]]; 

              let extendedFingers = 0;
              for(let i = 1; i < 5; i++) { 
                const distTip = Math.hypot(tips[i].x - wrist.x, tips[i].y - wrist.y);
                const distPip = Math.hypot(pips[i].x - wrist.x, pips[i].y - wrist.y);
                if (distTip > distPip * 1.2) extendedFingers++;
              }

              const isFist = extendedFingers === 0;
              const isOpenPalm = extendedFingers >= 4;

              const thumbTip = landmarks[4];
              const indexTip = landmarks[8];
              const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
              const isPinching = pinchDist < 0.05;

              const centroidX = 1 - landmarks[9].x; 
              const centroidY = landmarks[9].y;
              setHandPosition({ x: centroidX, y: centroidY });

              if (isFist && currentMode !== AppMode.TREE) setMode(AppMode.TREE);
              else if (isOpenPalm && currentMode === AppMode.TREE) setMode(AppMode.SCATTERED);

              if (currentMode === AppMode.SCATTERED && !isPinching) setIsCameraRotating(true);
              else setIsCameraRotating(false);
            } else {
               setIsCameraRotating(false);
            }
        } catch (e) {
            // ignore
        }
      }
      animationFrameId = requestAnimationFrame(predictWebcam);
    };

    setupMediaPipe();

    return () => {
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      if (handLandmarker) handLandmarker.close();
      if (videoRef.current && videoRef.current.srcObject) {
         const stream = videoRef.current.srcObject;
         stream.getTracks().forEach(track => track.stop());
      }
    };
  }, [currentMode, setMode, setHandPosition, setIsCameraRotating]);

  return (
    <div className="absolute top-4 left-4 z-50 pointer-events-none transition-opacity">
      <video ref={videoRef} className="w-32 h-24 rounded-lg border border-gold-500 scale-x-[-1] opacity-50 hidden" autoPlay playsInline muted />
      <div className={`text-[10px] uppercase font-bold tracking-widest bg-black/50 p-1 rounded inline-block ${status === 'denied' ? 'text-red-500' : 'text-yellow-500'}`}>
        {status === "init" && "Initializing Vision..."}
        {status === "ready" && "Vision Active"}
        {status === "denied" && "Camera Access Denied"}
        {status === "error" && "Vision Error"}
      </div>
    </div>
  );
};

// --- SCENE COMPONENTS ---

const ParticleMaterial = {
  uniforms: {
    uTime: { value: 0 },
    uColor1: { value: new THREE.Color('#2E8B57') },
    uColor2: { value: new THREE.Color('#FFD700') }, 
    uColor3: { value: new THREE.Color('#B22222') }, 
    uMode: { value: 0 }, 
  },
  vertexShader: `
    uniform float uTime;
    uniform float uMode;
    attribute vec3 aRandomPos;
    attribute float aSize;
    attribute float aColorIdx;
    varying vec3 vColor;
    varying float vAlpha;
    uniform vec3 uColor1;
    uniform vec3 uColor2;
    uniform vec3 uColor3;
    vec3 snoiseVec3( vec3 x ){
      float s =  sin( x.x * 32.3 + x.y * 3.4 + uTime * 0.5 );
      float c =  cos( x.z * 12.1 + x.x * 3.4 + uTime * 0.5 );
      return vec3(s, c, s*c) * 0.1;
    }
    void main() {
      vec3 targetPos = mix(position, aRandomPos, uMode);
      if (uMode > 0.5) {
         targetPos += snoiseVec3(targetPos) * uMode;
      } else {
         targetPos += snoiseVec3(targetPos * 5.0) * 0.05;
      }
      vColor = aColorIdx < 0.33 ? uColor1 : (aColorIdx < 0.66 ? uColor2 : uColor3);
      float blink = sin(uTime * 5.0 + aRandomPos.x * 10.0) * 0.5 + 0.5;
      vColor = mix(vColor, vec3(1.0, 1.0, 0.8), blink * 0.2); 
      vec4 mvPosition = modelViewMatrix * vec4(targetPos, 1.0);
      gl_PointSize = aSize * (300.0 / -mvPosition.z);
      gl_Position = projectionMatrix * mvPosition;
      vAlpha = 1.0;
    }
  `,
  fragmentShader: `
    varying vec3 vColor;
    varying float vAlpha;
    void main() {
      float r = distance(gl_PointCoord, vec2(0.5));
      if (r > 0.5) discard;
      float glow = 1.0 - (r * 2.0);
      glow = pow(glow, 1.5);
      gl_FragColor = vec4(vColor, vAlpha * glow);
    }
  `
};

const TreeParticles = () => {
  const meshRef = useRef(null);
  const shaderRef = useRef(null);
  const mode = useStore((state) => state.mode);
  const COUNT = 40000;

  const { positions, randomPos, colors, sizes } = useMemo(() => {
    const pos = new Float32Array(COUNT * 3);
    const rand = new Float32Array(COUNT * 3);
    const col = new Float32Array(COUNT);
    const sz = new Float32Array(COUNT);
    for (let i = 0; i < COUNT; i++) {
      const h = (Math.random() * 15) - 7.5; 
      const normalizedH = (h + 7.5) / 15; 
      const maxRadius = (1.0 - normalizedH) * 5.0; 
      const r = Math.random() * maxRadius;
      const theta = Math.random() * Math.PI * 2;
      pos[i * 3] = r * Math.cos(theta);
      pos[i * 3 + 1] = h;
      pos[i * 3 + 2] = r * Math.sin(theta);
      rand[i * 3] = (Math.random() - 0.5) * 30;
      rand[i * 3 + 1] = (Math.random() - 0.5) * 30;
      rand[i * 3 + 2] = (Math.random() - 0.5) * 30;
      col[i] = Math.random();
      sz[i] = Math.random() * 0.15 + 0.05;
    }
    return { positions: pos, randomPos: rand, colors: col, sizes: sz };
  }, []);

  useFrame((state, delta) => {
    if (shaderRef.current) {
      shaderRef.current.uniforms.uTime.value = state.clock.elapsedTime;
      const targetMode = mode === AppMode.TREE ? 0 : 1;
      damp(shaderRef.current.uniforms.uMode, 'value', targetMode, 1.5, delta);
    }
    if (meshRef.current && mode === AppMode.TREE) {
      meshRef.current.rotation.y += delta * 0.1;
    }
  });

  return (
    <points ref={meshRef}>
      <bufferGeometry>
        <bufferAttribute attach="attributes-position" count={COUNT} array={positions} itemSize={3} />
        <bufferAttribute attach="attributes-aRandomPos" count={COUNT} array={randomPos} itemSize={3} />
        <bufferAttribute attach="attributes-aColorIdx" count={COUNT} array={colors} itemSize={1} />
        <bufferAttribute attach="attributes-aSize" count={COUNT} array={sizes} itemSize={1} />
      </bufferGeometry>
      <shaderMaterial 
        ref={shaderRef} 
        args={[ParticleMaterial]} 
        transparent 
        depthWrite={false} 
        blending={THREE.AdditiveBlending}
      />
    </points>
  );
};

const Polaroid = ({ data, isFocused }) => {
  const texture = useMemo(() => new THREE.TextureLoader().load(data.url), [data.url]);
  const groupRef = useRef(null);
  const mode = useStore(state => state.mode);
  const setFocusedPhotoId = useStore(state => state.setFocusedPhotoId);
  const handPosition = useStore(state => state.handPosition);
  const { camera, raycaster } = useThree();
  const [hovered, setHovered] = useState(false);

  useFrame((state, delta) => {
    let targetPos = new THREE.Vector3();
    let targetRot = new THREE.Euler();
    let targetScale = 1;

    if (isFocused && mode === AppMode.FOCUSED) {
      targetPos.set(0, 0, 10); 
      targetRot.set(0, 0, 0);
      targetScale = 3.0;
    } else if (mode === AppMode.TREE) {
      targetPos.copy(data.position);
      targetRot.setFromVector3(data.rotation);
      const angle = Math.atan2(targetPos.x, targetPos.z);
      targetRot.y = angle;
      targetScale = 1;
    } else {
      targetPos.copy(data.scatterPosition);
      targetRot.set(data.rotation.x, data.rotation.y + state.clock.elapsedTime * 0.2, data.rotation.z);
      targetScale = 1.2;
    }

    if (groupRef.current) {
      damp3(groupRef.current.position, targetPos, 0.8, delta);
      damp3(groupRef.current.rotation, [targetRot.x, targetRot.y, targetRot.z], 0.8, delta);
      damp(groupRef.current.scale, 'x', targetScale, 0.5, delta);
      damp(groupRef.current.scale, 'y', targetScale, 0.5, delta);
      damp(groupRef.current.scale, 'z', targetScale, 0.5, delta);
    }
    
    const ndcX = (handPosition.x * 2) - 1;
    const ndcY = -(handPosition.y * 2) + 1; 
    raycaster.setFromCamera(new THREE.Vector2(ndcX, ndcY), camera);
    if (groupRef.current) {
        const intersects = raycaster.intersectObject(groupRef.current, true);
        const isHit = intersects.length > 0;
        if (isHit && !hovered) setHovered(true);
        if (!isHit && hovered) setHovered(false);
    }
  });
  
  return (
    <group 
        ref={groupRef} 
        onClick={(e) => { e.stopPropagation(); setFocusedPhotoId(isFocused ? null : data.id); useStore.getState().setMode(isFocused ? AppMode.SCATTERED : AppMode.FOCUSED) }}
        onPointerOver={() => setHovered(true)}
        onPointerOut={() => setHovered(false)}
    >
        <mesh position={[0, 0, 0.01]}>
            <boxGeometry args={[1.2, 1.5, 0.02]} />
            <meshStandardMaterial color={hovered ? "#fffacd" : "#ffffff"} roughness={0.2} metalness={0.1} />
        </mesh>
        <mesh position={[0, 0.1, 0.03]}>
            <planeGeometry args={[1, 1]} />
            <meshBasicMaterial map={texture} side={THREE.DoubleSide} />
        </mesh>
        <mesh position={[0, 0, -0.01]} rotation={[0, Math.PI, 0]}>
             <planeGeometry args={[1.2, 1.5]} />
             <meshStandardMaterial color="#f0f0f0" roughness={0.8} />
        </mesh>
    </group>
  );
};

const CameraController = () => {
    const { camera } = useThree();
    const mode = useStore(state => state.mode);
    const handPosition = useStore(state => state.handPosition);
    const isCameraRotating = useStore(state => state.isCameraRotating);
    const orbitRef = useRef(null);

    useFrame((state, delta) => {
        if (mode === AppMode.FOCUSED) {
            damp3(camera.position, [0, 0, 18], 1.5, delta);
        } else if (mode === AppMode.TREE) {
            damp3(camera.position, [0, 2, 20], 2, delta);
        } else if (mode === AppMode.SCATTERED) {
             if (isCameraRotating && orbitRef.current) {
                const targetAzimuth = (handPosition.x - 0.5) * 4; 
                const r = 25;
                const x = r * Math.sin(targetAzimuth);
                const z = r * Math.cos(targetAzimuth);
                const y = (handPosition.y - 0.5) * 10;
                damp3(camera.position, [x, y, z], 1, delta);
                state.camera.lookAt(0,0,0);
             }
        }
    });

    return <OrbitControls ref={orbitRef} enablePan={false} enableZoom={true} maxDistance={40} minDistance={5} />;
}

const TreeScene = () => {
  const photos = useStore(state => state.photos);
  const focusedPhotoId = useStore(state => state.focusedPhotoId);
  return (
    <div className="w-full h-screen bg-black relative">
      <Canvas dpr={[1, 2]} gl={{ antialias: false, toneMapping: THREE.ReinhardToneMapping, toneMappingExposure: 1.5 }}>
        <PerspectiveCamera makeDefault position={[0, 0, 20]} fov={60} />
        <CameraController />
        <color attach="background" args={['#050805']} />
        <ambientLight intensity={0.2} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#ffaa00" />
        <spotLight position={[-10, 20, 5]} angle={0.3} penumbra={1} intensity={2} color="#ffffff" castShadow />
        <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
        <TreeParticles />
        <group>
            {photos.map(photo => (
                <Polaroid key={photo.id} data={photo} isFocused={focusedPhotoId === photo.id} />
            ))}
        </group>
        <EffectComposer enableNormalPass={false}>
           <Bloom luminanceThreshold={0.5} mipmapBlur intensity={1.5} radius={0.6} />
           <Noise opacity={0.05} />
           <Vignette eskil={false} offset={0.1} darkness={0.8} />
        </EffectComposer>
      </Canvas>
    </div>
  );
};

// --- UI OVERLAY ---

const UIOverlay = () => {
  const mode = useStore(state => state.mode);
  const addPhoto = useStore(state => state.addPhoto);

  const handleFileUpload = (e) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      const url = URL.createObjectURL(file);
      addPhoto(url);
    }
  };

  return (
    <div className="absolute inset-0 pointer-events-none flex flex-col justify-between p-8 text-white">
      <div className="flex justify-between items-start">
        <div>
          <h1 className="text-4xl cinzel text-gold-400 font-bold tracking-wider drop-shadow-[0_0_10px_rgba(255,215,0,0.5)]">
            LUMIÈRE NOËL
          </h1>
          <p className="text-sm text-gray-400 mt-1 uppercase tracking-widest">
            Interactive Memory Tree
          </p>
        </div>
        <div className="bg-black/40 backdrop-blur-md border border-white/10 px-4 py-2 rounded-full">
           <span className={`text-xs font-bold tracking-widest ${
               mode === AppMode.TREE ? 'text-green-400' : 
               mode === AppMode.SCATTERED ? 'text-yellow-400' : 'text-red-400'
           }`}>
             STATUS: {mode}
           </span>
        </div>
      </div>

      <div className="flex items-end justify-between pointer-events-auto">
        <div className="space-y-4 max-w-md">
           <div className="bg-black/60 backdrop-blur-md p-4 rounded-lg border border-white/10 shadow-2xl">
              <h3 className="text-gold-400 cinzel font-bold mb-2">Gesture Controls</h3>
              <ul className="text-sm space-y-2 text-gray-300">
                <li className="flex items-center gap-2">
                  <span className="w-2 h-2 rounded-full bg-green-500"></span>
                  <strong>Fist:</strong> Assemble Tree
                </li>
                <li className="flex items-center gap-2">
                   <span className="w-2 h-2 rounded-full bg-yellow-500"></span>
                   <strong>Open Hand:</strong> Scatter Memories
                </li>
                <li className="flex items-center gap-2">
                   <span className="w-2 h-2 rounded-full bg-blue-500"></span>
                   <strong>Move Hand:</strong> Rotate View
                </li>
                <li className="flex items-center gap-2">
                   <span className="w-2 h-2 rounded-full bg-red-500"></span>
                   <strong>Click:</strong> Focus Photo
                </li>
              </ul>
           </div>
        </div>
        <div className="flex flex-col items-end gap-2">
          <label className="cursor-pointer group">
            <input type="file" accept="image/*" onChange={handleFileUpload} className="hidden" />
            <div className="bg-gold-600/20 hover:bg-gold-600/40 border border-gold-500/50 text-gold-300 px-6 py-3 rounded-lg transition-all backdrop-blur-sm flex items-center gap-2 group-hover:shadow-[0_0_15px_rgba(255,215,0,0.3)]">
              <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
              <span className="cinzel font-bold">Add Memory</span>
            </div>
          </label>
        </div>
      </div>
    </div>
  );
};

// --- APP & ENTRY ---

const App = () => {
  return (
    <div className="w-full h-full text-white overflow-hidden">
      <GestureController />
      <TreeScene />
      <UIOverlay />
    </div>
  );
};

const rootElement = document.getElementById('root');
if (rootElement) {
  const root = createRoot(rootElement);
  root.render(<App />);
}
    </script>
  </body>
</html>
