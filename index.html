<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas Dreamscape | Pro Edition</title>
    <style>
        /* CSS Variables & Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital@1&display=swap');

        :root {
            --gold: #ffd700;
            --overlay-bg: #051410;
        }

        body {
            margin: 0;
            overflow: hidden;
            /* ä¾ç„¶ä¿ç•™æå…‰èƒŒæ™¯ä½œä¸ºåº•è‰²ï¼Œä¸Šé¢ä¼šæœ‰3Dæ˜Ÿç©ºè¦†ç›– */
            background: radial-gradient(circle at 50% 40%, #081812 0%, #030508 60%, #000000 100%);
            font-family: 'Cinzel', serif;
            user-select: none;
        }

        /* Canvas & UI Layers */
        #canvas-container { position: fixed; inset: 0; z-index: 1; }
        
        #ui-layer {
            position: fixed; inset: 0; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px;
            opacity: 0; transition: opacity 1s;
        }

        /* Cinematic Loading Screen */
        #overlay {
            position: fixed; inset: 0; z-index: 20;
            background: rgba(3, 5, 4, 0.95);
            backdrop-filter: blur(10px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-in-out;
            pointer-events: auto;
        }

        h1 {
            color: var(--gold);
            font-size: 3.5rem;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            margin-bottom: 10px;
            letter-spacing: 5px;
            text-align: center;
            font-weight: 700;
        }

        p { color: #a8dcd1; font-family: 'Playfair Display', serif; font-size: 1.2rem; letter-spacing: 1px;}

        .btn-upload {
            margin-top: 40px;
            padding: 15px 50px;
            font-size: 1.2rem;
            color: #000;
            font-weight: bold;
            background: linear-gradient(135deg, #ffd700, #ffec8b);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }
        .btn-upload:hover { transform: scale(1.05); box-shadow: 0 0 40px rgba(255, 215, 0, 0.7); }
        .btn-upload:disabled { filter: grayscale(1); cursor: not-allowed; transform: none; }

        /* HUD Elements */
        .hud-top-right {
            position: absolute; top: 30px; right: 30px;
            text-align: right;
        }
        
        #video-preview {
            width: 160px; height: 120px;
            border: 2px solid var(--gold);
            border-radius: 12px;
            opacity: 0.6;
            transform: scaleX(-1);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
        }

        .status-badge {
            display: inline-block;
            margin-top: 15px;
            padding: 8px 20px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--gold);
            color: var(--gold);
            font-weight: bold;
            font-size: 0.9rem;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            text-shadow: 0 0 10px rgba(255,215,0,0.5);
        }

        .controls-hint {
            position: absolute; bottom: 30px; left: 30px;
            color: rgba(255,255,255,0.7);
            font-size: 1rem;
            line-height: 2;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        .key { color: #ffec8b; font-weight: bold; margin-right: 10px; }

        #file-input { display: none; }
        
        .loader {
            width: 40px; height: 40px;
            border: 3px solid rgba(212,175,55,0.3);
            border-radius: 50%;
            border-top-color: var(--gold);
            animation: spin 1s ease-in-out infinite;
            margin-top: 20px;
            display: none;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="overlay">
        <h1>Christmas Dream</h1>
        <p>æŒ¥åŠ¨åŒæ‰‹ Â· ç‚¹äº®æ˜Ÿæ²³ Â· å”¤é†’è®°å¿†</p>
        <button id="upload-btn" class="btn-upload" onclick="document.getElementById('file-input').click()">å¼€å¯æ¢¦å¢ƒ</button>
        <div class="loader" id="loader"></div>
        <input type="file" id="file-input" multiple accept="image/*" onchange="initApp(this)">
        <p id="loading-msg" style="margin-top:15px; font-size: 0.9rem; opacity: 0; color: #ffd700;">æ­£åœ¨ç¼–ç»‡å…‰å½±...</p>
    </div>

    <div id="ui-layer">
        <div class="controls-hint">
            <div><span class="key">âœŠ æ¡æ‹³</span> èšåˆ | å¬å”¤åœ£è¯æ ‘</div>
            <div><span class="key">ğŸ– å¼ æ‰‹</span> æ•£å¼€ | æ¼«æ¸¸æ˜Ÿé™…</div>
            <div><span class="key">ğŸ¤ æåˆ</span> æŠ“å– | å”¤é†’è®°å¿†</div>
        </div>
        <div class="hud-top-right">
            <video id="video-preview" playsinline></video>
            <br>
            <div class="status-badge" id="status-text">ç³»ç»Ÿåˆå§‹åŒ–...</div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- ç²’å­ç€è‰²å™¨ -->
    <script type="x-shader/x-vertex" id="vertexShader">
        attribute float size;
        attribute vec3 customColor;
        attribute float flashOffset;
        
        varying vec3 vColor;
        varying float vAlpha;
        
        uniform float uTime;
        uniform float uPixelRatio;
        uniform float uMixFactor;
        
        attribute vec3 targetTree;
        attribute vec3 targetScatter;

        void main() {
            vec3 pos = mix(targetTree, targetScatter, uMixFactor);
            
            // ç²’å­æµ®åŠ¨å™ªéŸ³
            if (uMixFactor > 0.1) {
                float amp = 1.0; 
                pos.x += sin(uTime * 0.5 + pos.y * 0.1) * amp;
                pos.y += cos(uTime * 0.3 + pos.x * 0.1) * amp;
                pos.z += sin(uTime * 0.4 + pos.x * 0.1) * amp;
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            
            // é—ªçƒé€»è¾‘
            float flash = sin(uTime * 4.0 + flashOffset); 
            float brightness = 0.7 + 0.4 * flash; 
            
            // é¢œè‰²æ··åˆï¼šæ•£å¼€æ—¶ç¨å¾®åè“
            vec3 finalColor = customColor;
            if(uMixFactor > 0.8) {
                finalColor = mix(customColor, vec3(0.8, 0.9, 1.0), 0.3);
            }
            vColor = finalColor;

            gl_PointSize = size * uPixelRatio * (250.0 / -mvPosition.z) * brightness;
            gl_Position = projectionMatrix * mvPosition;
            
            vAlpha = brightness;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            // æŸ”å’Œå…‰ç‚¹
            float strength = 1.0 / (dist * 15.0);
            strength = clamp(strength, 0.0, 1.0);
            strength *= (1.0 - smoothstep(0.4, 0.5, dist));

            if (strength < 0.01) discard;

            gl_FragColor = vec4(vColor, strength * vAlpha);
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Config ---
        const CONSTANTS = {
            PARTICLE_COUNT: 25000,
            ORNAMENT_COUNT: 150,
            TREE_HEIGHT: 45,
            TREE_RADIUS: 16,
            COLORS: [
                new THREE.Color('#ffdd00'), new THREE.Color('#ff0000'), 
                new THREE.Color('#00ff44'), new THREE.Color('#ffffff'), 
                new THREE.Color('#00ccff')
            ]
        };

        const STATE = { TREE: 0, SCATTER: 1, DETAIL: 2, current: 0 };

        // --- Globals ---
        let scene, camera, renderer, composer;
        let particleSystem, particleUniforms;
        let ornaments = [];
        let photoMeshes = [];
        let cursorSprite;
        
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedPhoto = null;
        let hoveredPhoto = null; // æ–°å¢ï¼šæ‚¬åœçŠ¶æ€
        
        let targetMix = 0;
        let currentMix = 0;
        let sceneRotationTarget = { x: 0, y: 0 };
        
        let lastGestureTime = 0;
        let audioCtx; // éŸ³é¢‘ä¸Šä¸‹æ–‡

        // --- Sound System (Synthesized) ---
        const SoundFX = {
            init: () => {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            },
            playSparkle: () => {
                if(!audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.5);
            },
            playSnap: () => {
                if(!audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            }
        };

        // --- Bootstrap ---
        window.initApp = async (input) => {
            if (input.files.length === 0) return;
            
            // Lock UI
            const btn = document.getElementById('upload-btn');
            btn.disabled = true;
            btn.style.opacity = 0.5;
            document.getElementById('loader').style.display = 'block';
            document.getElementById('loading-msg').style.opacity = 1;

            SoundFX.init(); // åˆå§‹åŒ–éŸ³é¢‘
            initThree();
            
            try {
                await createPhotoGallery(input.files);
            } catch(e) { console.error(e); }

            const overlay = document.getElementById('overlay');
            overlay.style.opacity = 0;
            
            setTimeout(() => {
                overlay.style.display = 'none';
                document.getElementById('ui-layer').style.opacity = 1;
                if (location.protocol === 'https:' || location.hostname === 'localhost') {
                    initMediaPipe();
                } else {
                    document.getElementById('status-text').innerText = "æ‰‹åŠ¿éœ€è¦HTTPSç¯å¢ƒ";
                }
            }, 1000);
            
            animate();
        };

        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020406, 0.012); // Deep Space Fog

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 5, 70);

            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                powerPreference: "high-performance",
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.0; // è°ƒæ•´æ›å…‰
            container.appendChild(renderer.domElement);

            // Bloom Config (Prevent over-exposure)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.3; // æé«˜é˜ˆå€¼ï¼Œåªæœ‰å¾ˆäº®çš„ä¸œè¥¿æ‰å‘å…‰ï¼Œä¿æŠ¤ç…§ç‰‡
            bloomPass.strength = 0.8; 
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            const sunLight = new THREE.DirectionalLight(0xffaa00, 1.0);
            sunLight.position.set(20, 50, 20);
            scene.add(ambient, sunLight);

            createStaticStars(); // æ–°å¢å…¨æ™¯æ˜Ÿç©º
            createAdvancedParticles();
            createDecorations();
            createFairyCursor();
            
            window.addEventListener('resize', onResize);
        }

        // --- Visual: Background Stars (Static) ---
        function createStaticStars() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const sizes = [];
            for(let i=0; i<3000; i++) {
                const r = 200 + Math.random() * 200; // Far away
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                pos.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                sizes.push(Math.random() * 1.5);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const mat = new THREE.PointsMaterial({
                color: 0x88ccff,
                size: 1.0,
                transparent: true, 
                opacity: 0.8,
                sizeAttenuation: true
            });
            const stars = new THREE.Points(geo, mat);
            scene.add(stars);
        }

        // --- Visual: Tiny Fairy Cursor ---
        function createFairyCursor() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            // Star shape
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(16,16,6,0,Math.PI*2);
            ctx.fill();
            // Glow
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255, 255, 200, 1)');
            grad.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ 
                map: tex, 
                color: 0xffdd00, 
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            cursorSprite = new THREE.Sprite(mat);
            cursorSprite.scale.set(1.5, 1.5, 1); // å°ºå¯¸å‡å°
            cursorSprite.visible = false;
            
            // Point light attached
            const light = new THREE.PointLight(0xffaa00, 2, 10);
            cursorSprite.add(light);

            scene.add(cursorSprite);
        }

        // --- Visual: Particles ---
        function createAdvancedParticles() {
            const geometry = new THREE.BufferGeometry();
            const count = CONSTANTS.PARTICLE_COUNT;
            const targetTree = []; const targetScatter = [];
            const colors = []; const sizes = []; const flashOffsets = [];

            for (let i = 0; i < count; i++) {
                // Tree
                const t = Math.random();
                const angle = t * Math.PI * 2 * 30; 
                const radius = (1 - t) * CONSTANTS.TREE_RADIUS;
                const rOffset = Math.random() * 2; 
                targetTree.push(
                    Math.cos(angle) * (radius + rOffset),
                    (t * CONSTANTS.TREE_HEIGHT) - (CONSTANTS.TREE_HEIGHT / 2),
                    Math.sin(angle) * (radius + rOffset)
                );

                // Scatter
                const phi = Math.acos(-1 + (2 * i) / count);
                const theta = Math.sqrt(count * Math.PI) * phi;
                const rScatter = 50 + Math.random() * 50;
                targetScatter.push(
                    rScatter * Math.cos(theta) * Math.sin(phi),
                    rScatter * Math.sin(theta) * Math.sin(phi),
                    rScatter * Math.cos(phi)
                );

                const col = CONSTANTS.COLORS[Math.floor(Math.random() * CONSTANTS.COLORS.length)];
                colors.push(col.r, col.g, col.b);
                sizes.push(Math.random() * 0.6 + 0.2); 
                flashOffsets.push(Math.random() * Math.PI * 2);
            }

            geometry.setAttribute('targetTree', new THREE.Float32BufferAttribute(targetTree, 3));
            geometry.setAttribute('targetScatter', new THREE.Float32BufferAttribute(targetScatter, 3));
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(targetTree, 3));
            geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('flashOffset', new THREE.Float32BufferAttribute(flashOffsets, 1));

            particleUniforms = { uTime: { value: 0 }, uPixelRatio: { value: renderer.getPixelRatio() }, uMixFactor: { value: 0.0 } };

            const material = new THREE.ShaderMaterial({
                uniforms: particleUniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function createDecorations() {
            const geom = new THREE.SphereGeometry(0.8, 16, 16);
            const mat = new THREE.MeshPhysicalMaterial({ 
                color: 0xff0000, metalness: 0.7, roughness: 0.1, clearcoat: 1.0
            });
            const mesh = new THREE.InstancedMesh(geom, mat, CONSTANTS.ORNAMENT_COUNT);
            
            const dummy = new THREE.Object3D();
            const treePos = []; const scatterPos = [];

            for(let i=0; i<CONSTANTS.ORNAMENT_COUNT; i++) {
                const t = Math.random();
                const angle = Math.random() * Math.PI * 2;
                const r = (1 - t) * CONSTANTS.TREE_RADIUS * 0.8; 
                const h = (t * CONSTANTS.TREE_HEIGHT) - (CONSTANTS.TREE_HEIGHT/2);
                
                treePos.push(new THREE.Vector3(Math.cos(angle)*r, h, Math.sin(angle)*r));
                scatterPos.push(new THREE.Vector3((Math.random()-0.5)*120, (Math.random()-0.5)*120, (Math.random()-0.5)*120));
                
                dummy.position.copy(treePos[i]); dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            mesh.userData = { tree: treePos, scatter: scatterPos };
            scene.add(mesh);
            ornaments.push(mesh);
        }

        async function createPhotoGallery(files) {
            const loader = new THREE.TextureLoader();
            // è¾¹æ¡†æ”¹ç”¨ç•¥æš—çš„ç™½è‰²ï¼Œé˜²æ­¢Bloomè¿‡æ›
            const frameGeo = new THREE.BoxGeometry(4.2, 5.2, 0.1);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.5 }); 
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.8 });

            const maxPhotos = Math.min(files.length, 25);

            for (let i = 0; i < maxPhotos; i++) {
                try {
                    const url = URL.createObjectURL(files[i]);
                    const tex = await new Promise((res, rej) => loader.load(url, res, undefined, rej));
                    tex.colorSpace = THREE.SRGBColorSpace;
                    
                    // ä¿®å¤æ›å…‰ï¼šä½¿ç”¨ BasicMaterial å¹¶ç¨å¾®é™ä½äº®åº¦ (0xcccccc)
                    const photoMat = new THREE.MeshBasicMaterial({ map: tex, color: 0xcccccc });
                    
                    const group = new THREE.Group();
                    const frame = new THREE.Mesh(frameGeo, frameMat);
                    const photo = new THREE.Mesh(new THREE.PlaneGeometry(3.8, 3.8), photoMat);
                    photo.position.set(0, 0.5, 0.06);
                    
                    const back = new THREE.Mesh(new THREE.PlaneGeometry(4, 5), goldMat);
                    back.position.set(0, 0, -0.06);
                    back.rotation.y = Math.PI;

                    group.add(frame, photo, back);
                    // å¢åŠ ä¸å¯è§çš„HitBoxä»¥æé«˜æŠ“å–åˆ¤å®šèŒƒå›´
                    const hitBox = new THREE.Mesh(new THREE.BoxGeometry(5, 6, 2), new THREE.MeshBasicMaterial({visible:false}));
                    group.add(hitBox);

                    const t = Math.random() * 0.85 + 0.1;
                    const angle = i * (Math.PI * 2 / maxPhotos) + Math.random();
                    const r = ((1 - t) * CONSTANTS.TREE_RADIUS) + 3;
                    const h = (t * CONSTANTS.TREE_HEIGHT) - (CONSTANTS.TREE_HEIGHT/2);

                    group.position.set(Math.cos(angle)*r, h, Math.sin(angle)*r);
                    group.lookAt(0, h, 0);

                    group.userData = {
                        treePos: group.position.clone(), treeRot: group.quaternion.clone(),
                        scatterPos: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80),
                        scatterRot: new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.random()*3, Math.random()*3, 0))
                    };

                    photoMeshes.push(group);
                    scene.add(group);
                } catch(e) {}
            }
        }

        // --- Logic: Hand Tracking & Interactions ---

        async function initMediaPipe() {
            if (!window.Hands) return;
            const video = document.getElementById('video-preview');
            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);
            
            const cam = new window.Camera(video, {
                onFrame: async () => await hands.send({image: video}),
                width: 320, height: 240
            });
            cam.start();
        }

        let smoothHand = {x:0.5, y:0.5};

        function onHandsResults(results) {
            const statusEl = document.getElementById('status-text');
            
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                statusEl.innerText = "ç­‰å¾…æ‰‹åŠ¿...";
                cursorSprite.visible = false;
                hoveredPhoto = null;
                return;
            }

            cursorSprite.visible = true;
            const lm = results.multiHandLandmarks[0];
            
            // 1. å¹³æ»‘å¤„ç†
            const rawX = lm[9].x; 
            const rawY = lm[9].y;
            smoothHand.x += (rawX - smoothHand.x) * 0.2;
            smoothHand.y += (rawY - smoothHand.y) * 0.2;

            // 2. æ›´æ–° 3D å…‰æ ‡
            mouse.x = (1 - smoothHand.x) * 2 - 1;
            mouse.y = -(smoothHand.y * 2 - 1);
            
            const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const dist = 35; 
            const targetPos = camera.position.clone().add(dir.multiplyScalar(dist));
            cursorSprite.position.lerp(targetPos, 0.2);

            // 3. å®æ—¶ Raycast æ£€æµ‹æ‚¬åœ (æé«˜ç²¾åº¦å…³é”®)
            checkHover();

            // 4. æ‰‹åŠ¿è¯†åˆ«
            const now = Date.now();
            if (now - lastGestureTime > 300) {
                detectGesture(lm, statusEl);
            }
        }

        // ä¼˜åŒ–æŠ“å–ç²¾åº¦çš„æ ¸å¿ƒï¼šæ‚¬åœæ£€æµ‹
        function checkHover() {
            if (STATE.current !== STATE.SCATTER && STATE.current !== STATE.DETAIL) return;
            
            raycaster.setFromCamera(mouse, camera);
            // æ£€æµ‹æ˜¯å¦æœ‰ç‰©ä½“åœ¨é¼ æ ‡å°„çº¿ä¸Š
            const intersects = raycaster.intersectObjects(photoMeshes, true);
            
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
                
                if (hoveredPhoto !== obj) {
                    hoveredPhoto = obj;
                    // æ‚¬åœæ—¶ï¼Œå…‰æ ‡å˜çº¢ï¼Œæç¤ºå¯æŠ“å–
                    cursorSprite.material.color.setHex(0xff3333); 
                }
            } else {
                hoveredPhoto = null;
                // æ— æ‚¬åœï¼Œå…‰æ ‡æ¢å¤é‡‘è‰²
                cursorSprite.material.color.setHex(0xffdd00);
            }
        }

        function detectGesture(lm, statusEl) {
            const isFingerDown = (tip, pip) => lm[tip].y > lm[pip].y;
            const isFist = isFingerDown(8,6) && isFingerDown(12,10) && isFingerDown(16,14) && isFingerDown(20,18);
            const isOpen = !isFingerDown(8,6) && !isFingerDown(12,10) && !isFingerDown(16,14) && !isFingerDown(20,18);
            
            const dx = lm[4].x - lm[8].x;
            const dy = lm[4].y - lm[8].y;
            const pinchDist = Math.sqrt(dx*dx + dy*dy);

            // è°ƒæ•´æŠ“å–åˆ¤å®šï¼šæåˆè·ç¦» < 0.04 ä¸” å½“å‰æœ‰æ‚¬åœç‰©ä½“
            if (pinchDist < 0.04) {
                if (hoveredPhoto) {
                    statusEl.innerText = "âœ¨ æŠ“å–æˆåŠŸ";
                    handleGrab(hoveredPhoto);
                } else {
                    statusEl.innerText = "ğŸ¤ æåˆ (æœªé€‰ä¸­)";
                }
            } else if (isFist) {
                statusEl.innerText = "âœŠ èšåˆ";
                changeState(STATE.TREE);
            } else if (isOpen) {
                statusEl.innerText = "ğŸ– æ˜Ÿé™…æ¼«æ¸¸";
                changeState(STATE.SCATTER);
                sceneRotationTarget.x = (smoothHand.y - 0.5) * 2; 
                sceneRotationTarget.y = (smoothHand.x - 0.5) * 2;
            }
        }

        function changeState(newState) {
            if (STATE.current === newState && newState !== STATE.SCATTER) return;
            
            SoundFX.playSparkle(); // æ’­æ”¾éŸ³æ•ˆ

            if (STATE.current === STATE.DETAIL && newState !== STATE.DETAIL) {
                 if(selectedPhoto) gsap.to(selectedPhoto.scale, {x:1, y:1, z:1, duration: 0.5});
                 selectedPhoto = null;
            }

            gsap.to(camera.position, {
                z: newState === STATE.TREE ? 70 : 40,
                duration: 1.5,
                ease: "power2.inOut"
            });

            STATE.current = newState;
            targetMix = (newState === STATE.TREE) ? 0 : 1;
        }

        function handleGrab(obj) {
            if (obj === selectedPhoto) return;
            
            SoundFX.playSnap(); // æ’­æ”¾æŠ“å–éŸ³æ•ˆ

            if(selectedPhoto) gsap.to(selectedPhoto.scale, {x:1, y:1, z:1, duration: 0.5});
            
            selectedPhoto = obj;
            STATE.current = STATE.DETAIL;

            const offset = new THREE.Vector3(0, 0, -12).applyQuaternion(camera.quaternion);
            const targetPos = camera.position.clone().add(offset);
            
            gsap.to(selectedPhoto.position, {
                x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 1
            });
            gsap.to(selectedPhoto.quaternion, {
                x: camera.quaternion.x, y: camera.quaternion.y, z: camera.quaternion.z, w: camera.quaternion.w, duration: 1
            });
            gsap.to(selectedPhoto.scale, {x: 2.2, y: 2.2, z: 2.2, duration: 1});
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            
            if(particleUniforms) {
                particleUniforms.uTime.value = time;
                currentMix += (targetMix - currentMix) * 0.05;
                particleUniforms.uMixFactor.value = currentMix;
            }

            // Animate Ornaments
            ornaments.forEach(mesh => {
                const dummy = new THREE.Object3D();
                for(let i=0; i<CONSTANTS.ORNAMENT_COUNT; i++) {
                    const tp = mesh.userData.tree[i];
                    const sp = mesh.userData.scatter[i];
                    dummy.position.lerpVectors(tp, sp, currentMix);
                    dummy.rotation.set(time+i, time+i, 0);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                mesh.instanceMatrix.needsUpdate = true;
            });

            // Animate Photos
            photoMeshes.forEach(mesh => {
                if(mesh === selectedPhoto && STATE.current === STATE.DETAIL) return;
                const tp = mesh.userData.treePos; const tr = mesh.userData.treeRot;
                const sp = mesh.userData.scatterPos; const sr = mesh.userData.scatterRot;

                mesh.position.lerpVectors(tp, sp, currentMix);
                mesh.quaternion.slerpQuaternions(tr, sr, currentMix);
                
                if(currentMix > 0.5) mesh.position.y += Math.sin(time + mesh.id)*0.03;
            });

            // Animate Cursor Blink (High Frequency)
            if(cursorSprite) {
                const blink = Math.sin(time * 15) * 0.5 + 0.5; // Fast blink
                cursorSprite.material.opacity = 0.5 + blink * 0.5;
                const light = cursorSprite.children[0];
                if(light) light.intensity = 1 + blink * 2;
            }

            if (STATE.current === STATE.TREE) {
                scene.rotation.y += 0.001; 
                scene.rotation.x *= 0.95;
            } else if (STATE.current === STATE.SCATTER) {
                scene.rotation.y += (sceneRotationTarget.y * 0.5 - scene.rotation.y) * 0.05;
                scene.rotation.x += (sceneRotationTarget.x * 0.5 - scene.rotation.x) * 0.05;
            }

            composer.render();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            if(particleUniforms) particleUniforms.uPixelRatio.value = renderer.getPixelRatio();
        }
    </script>
</body>
</html>
