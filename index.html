<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Dream - Robust Version</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020505; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        #video-preview {
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; 
            border: 1px solid rgba(212, 175, 55, 0.3); border-radius: 8px; transform: scaleX(-1); opacity: 0.5;
            display: none; /* ÈªòËÆ§ÈöêËóèÔºåÂºÄÂêØÊàêÂäüÂêéÂÜçÊòæÁ§∫ */
        }

        #status-bar {
            color: #D4AF37; text-shadow: 0 0 10px #D4AF37; font-size: 14px; background: rgba(0,0,0,0.6);
            padding: 15px; border-radius: 8px; pointer-events: auto; max-width: 350px;
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
        
        #upload-btn {
            pointer-events: auto; cursor: pointer; background: rgba(212, 175, 55, 0.1); border: 1px solid #D4AF37;
            color: #D4AF37; padding: 8px 16px; border-radius: 20px; transition: 0.3s; text-transform: uppercase;
            font-size: 12px; font-weight: bold; margin-top: 15px; display: inline-block; text-align: center;
        }
        #upload-btn:hover { background: #D4AF37; color: #000; box-shadow: 0 0 15px #D4AF37; }
        
        /* Loading Ê†∑Âºè‰ºòÂåñ */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #020505; z-index: 100;
            display: flex; justify-content: center; align-items: center; color: #D4AF37; flex-direction: column;
            transition: opacity 0.8s;
            text-align: center;
        }
        .spinner {
            width: 40px; height: 40px; border: 2px solid transparent; border-top-color: #D4AF37; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* ÈîôËØØÊèêÁ§∫ */
        #error-log {
            color: #ff4444; margin-top: 15px; font-size: 12px; max-width: 80%;
        }
        
        .highlight-text { color: #fff; text-shadow: 0 0 5px #fff; }
    </style>
    
    <!-- ÂºïÂÖ• Three.js (‰ΩøÁî®Êõ¥Á®≥ÂÆöÁöÑ unpkg) -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/gsap@3.12.2/dist/gsap.min.js"></script>
    
    <!-- MediaPipe Hands (‰ΩøÁî® jsdelivr) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <div id="loader-text">INITIALIZING MAGIC...</div>
    <div id="error-log"></div>
    <button id="force-start-btn" style="margin-top:20px; padding:5px 10px; background:#333; color:#aaa; border:1px solid #555; display:none; cursor:pointer;">Skip Camera & Start</button>
</div>

<div id="ui-layer">
    <div id="status-bar">
        <div>STATE: <span id="state-text" class="highlight-text">TREE (MERGED)</span></div>
        <div style="font-size: 12px; margin-top:5px; color:#aaa; line-height: 1.6;">
            üëä FIST: Merge Tree<br>
            üñê OPEN: Scatter Mode<br>
            ‚ú® <strong>CURSOR:</strong> Point at photo<br>
            üëå <strong>PINCH:</strong> Grab highlighted photo
        </div>
        <label id="upload-btn">
            + Add Memories
            <input type="file" id="file-input" multiple accept="image/*" style="display:none;">
        </label>
    </div>
</div>

<video id="video-preview" playsinline></video>
<div id="canvas-container"></div>

<script>
// Êó•ÂøóËæÖÂä©
function logError(msg) {
    console.error(msg);
    const el = document.getElementById('error-log');
    if(el) el.innerText = "Error: " + msg;
    // Âá∫Áé∞ÈîôËØØÊòæÁ§∫Ë∑≥ËøáÊåâÈíÆ
    document.getElementById('force-start-btn').style.display = 'inline-block';
}

function hideLoader() {
    const loader = document.getElementById('loader');
    if(loader && loader.style.display !== 'none') {
        loader.style.opacity = '0';
        setTimeout(() => loader.style.display = 'none', 800);
    }
}

// Âº∫Âà∂ÂêØÂä®ÊåâÈíÆ
document.getElementById('force-start-btn').addEventListener('click', hideLoader);

/**
 * ÈÖçÁΩÆ
 */
const CONFIG = {
    particleCount: 40000,
    treeHeight: 60,
    treeRadius: 25,
    colors: [0xD4AF37, 0xC41E3A, 0x2E8B57], 
    bloom: { strength: 1.6, radius: 0.5, threshold: 0.15 },
    cursorSmoothing: 0.15 
};

const STATE = {
    current: 'TREE',
    handDetected: false,
    focusedPhoto: null,
    hoveredPhoto: null, 
    rotationSpeed: 0,
    targetRotationY: 0
};

let scene, camera, renderer, composer;
let treeSystem, snowSystem, cursorSprite;
let photos = []; 
let raycaster = new THREE.Raycaster();

let rawMouse = new THREE.Vector2();     
let smoothedMouse = new THREE.Vector2();

/**
 * 1. ÂàùÂßãÂåñ Three.js
 */
function initThree() {
    try {
        const container = document.getElementById('canvas-container');
        
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020505, 0.02);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 85);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            CONFIG.bloom.strength, CONFIG.bloom.radius, CONFIG.bloom.threshold
        );
        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const pLight = new THREE.PointLight(0xD4AF37, 1.2, 100);
        pLight.position.set(0, 30, 20);
        scene.add(pLight);

        createTreeParticles();
        createSnow();
        createCursor();
        
        window.addEventListener('resize', onWindowResize, false);
        
        // ÊàêÂäüÊ∏≤ÊüìÁ¨¨‰∏ÄÂ∏ßÂêéÔºåÂ¶ÇÊûúMediaPipeËøòÂú®Âä†ËΩΩÔºåÂèØ‰ª•ÂÖà‰∏çÁÆ°ÔºåËá≥Â∞ëÂú∫ÊôØÂá∫Êù•‰∫Ü
        animate(); 

    } catch (e) {
        logError("WebGL Init Failed: " + e.message);
    }
}

function createCursor() {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
    grad.addColorStop(0, 'rgba(255, 255, 230, 1)'); 
    grad.addColorStop(0.4, 'rgba(212, 175, 55, 0.5)'); 
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,64,64);

    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ 
        map: texture, color: 0xffffff, transparent: true, opacity: 0, depthTest: false 
    });
    cursorSprite = new THREE.Sprite(material);
    cursorSprite.scale.set(3, 3, 1);
    cursorSprite.renderOrder = 999;
    scene.add(cursorSprite);
}

function createTreeParticles() {
    const geometry = new THREE.BufferGeometry();
    const positions = [], colors = [], sizes = [], originalPos = [], scatteredPos = [];
    const colorObj = new THREE.Color();

    for (let i = 0; i < CONFIG.particleCount; i++) {
        const y = Math.random() * CONFIG.treeHeight; 
        const r = (CONFIG.treeHeight - y) / CONFIG.treeHeight * CONFIG.treeRadius;
        const angle = y * 1.5 + Math.random() * Math.PI * 2;
        const offset = Math.random() * 2;
        
        const tx = Math.cos(angle) * (r + offset);
        const tz = Math.sin(angle) * (r + offset);
        const ty = y - CONFIG.treeHeight / 2;

        positions.push(tx, ty, tz);
        originalPos.push(tx, ty, tz);
        scatteredPos.push((Math.random()-0.5)*120, (Math.random()-0.5)*120, (Math.random()-0.5)*120);

        const rand = Math.random();
        let hex = rand > 0.95 ? CONFIG.colors[0] : (rand > 0.85 ? CONFIG.colors[1] : CONFIG.colors[2]);
        colorObj.setHex(hex);
        colors.push(colorObj.r, colorObj.g, colorObj.b);
        sizes.push(Math.random() * 0.5 + 0.1);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
    geometry.setAttribute('aScatter', new THREE.Float32BufferAttribute(scatteredPos, 3));
    geometry.setAttribute('aOriginal', new THREE.Float32BufferAttribute(originalPos, 3));

    const material = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            pointTexture: { value: new THREE.TextureLoader().load('https://assets.codepen.io/127738/dotTexture.png') },
            mixVal: { value: 0.0 }
        },
        vertexShader: `
            attribute float size; attribute vec3 color; attribute vec3 aScatter; attribute vec3 aOriginal;
            varying vec3 vColor; uniform float time; uniform float mixVal;
            void main() {
                vColor = color;
                vec3 pos = mix(aOriginal, aScatter, mixVal);
                float pulse = sin(time * 3.0 + pos.y * 0.1) * 0.2 + 1.0;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = size * pulse * (350.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            uniform sampler2D pointTexture; varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
                if (gl_FragColor.a < 0.5) discard;
            }
        `,
        depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
    });

    treeSystem = new THREE.Points(geometry, material);
    scene.add(treeSystem);
}

function createSnow() {
    const geo = new THREE.BufferGeometry();
    const verts = [];
    for(let i=0; i<3000; i++) verts.push((Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*200);
    geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
    snowSystem = new THREE.Points(geo, new THREE.PointsMaterial({color:0xffffff, size:0.6, transparent:true, opacity:0.6}));
    scene.add(snowSystem);
}

document.getElementById('file-input').addEventListener('change', (e) => {
    const files = e.target.files;
    if(!files.length) return;
    for(let i=0; i<Math.min(files.length, 15); i++) {
        const r = new FileReader();
        r.onload = (evt) => createPolaroid(evt.target.result);
        r.readAsDataURL(files[i]);
    }
});

function createPolaroid(url) {
    new THREE.TextureLoader().load(url, (tex) => {
        const grp = new THREE.Group();
        const frame = new THREE.Mesh(new THREE.PlaneGeometry(6, 7.2), new THREE.MeshBasicMaterial({color:0xffffff}));
        const pic = new THREE.Mesh(new THREE.PlaneGeometry(5.2, 5.2), new THREE.MeshBasicMaterial({map:tex}));
        pic.position.set(0, 0.6, 0.05);
        grp.add(frame); grp.add(pic);
        
        const y = (Math.random()-0.5) * CONFIG.treeHeight;
        const r = ((CONFIG.treeHeight/2 - y)/CONFIG.treeHeight * CONFIG.treeRadius) + 4;
        const ang = Math.random() * 6.28;
        
        grp.userData = {
            treePos: new THREE.Vector3(Math.cos(ang)*r, y, Math.sin(ang)*r),
            treeRot: new THREE.Euler(0, -ang, 0),
            scatterPos: new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*80, (Math.random()-0.5)*50),
            scatterRot: new THREE.Euler(Math.random()*3, Math.random()*3, 0)
        };
        
        grp.position.copy(grp.userData.treePos);
        grp.rotation.copy(grp.userData.treeRot);
        grp.lookAt(0, y, 0);
        
        scene.add(grp);
        photos.push(grp);
        gsap.from(grp.scale, {x:0, y:0, z:0, duration:1, ease:"back.out(1.7)"});
    });
}

/**
 * MediaPipe ÈÄªËæë - Â¢ûÂä†ÈîôËØØÂ§ÑÁêÜ
 */
async function setupMediaPipe() {
    const vid = document.getElementById('video-preview');
    const loaderText = document.getElementById('loader-text');
    
    loaderText.innerText = "LOADING AI MODELS...";

    try {
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.6 });
        hands.onResults(onHandResults);
        
        loaderText.innerText = "ACCESSING CAMERA...";
        
        const cameraUtils = new Camera(vid, {
            onFrame: async () => {
                await hands.send({image: vid});
            },
            width: 320, height: 240
        });
        
        await cameraUtils.start();
        
        // Âè™ÊúâÂΩìÊëÑÂÉèÂ§¥ÊàêÂäüÂºÄÂêØÔºåÊâçÈöêËóèLoaderÔºåÂπ∂ÊòæÁ§∫È¢ÑËßàÁ™óÂè£
        vid.style.display = "block";
        hideLoader();

    } catch (error) {
        logError("Camera/AI Error: " + error.message + ". Please try Local Server or check HTTPS.");
    }
}

function onHandResults(res) {
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        STATE.handDetected = true;
        const landmarks = res.multiHandLandmarks[0];
        
        const ndcX = (1 - landmarks[8].x) * 2 - 1; 
        const ndcY = (1 - landmarks[8].y) * 2 - 1;
        rawMouse.set(ndcX, ndcY);

        const gesture = detectGesture(landmarks);
        handleStateChange(gesture);
        
        if (STATE.current === 'SCATTER' && gesture !== 'PINCH') {
            const palmX = landmarks[9].x; 
            const target = (0.5 - palmX) * 4; 
            STATE.targetRotationY += (target - STATE.targetRotationY) * 0.05;
        }
        
    } else {
        STATE.handDetected = false;
        if(cursorSprite) cursorSprite.visible = false;
    }
}

function detectGesture(lm) {
    const d = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
    const wrist = lm[0];
    const pinchDist = d(lm[4], lm[8]);
    const isFist = [8, 12, 16, 20].every(i => d(lm[i], wrist) < 0.25);
    const isOpen = [8, 12, 16, 20].every(i => d(lm[i], wrist) > 0.35);

    if (pinchDist < 0.05) return 'PINCH'; 
    if (isFist) return 'FIST';
    if (isOpen) return 'OPEN';
    return 'UNKNOWN';
}

function handleStateChange(gesture) {
    const status = document.getElementById('state-text');
    if (gesture === 'FIST' && STATE.current !== 'TREE') {
        STATE.current = 'TREE'; status.innerText = "TREE (MERGED)"; exitFocus();
        gsap.to(treeSystem.material.uniforms.mixVal, {value:0, duration:2});
        gsap.to(camera.position, {z:85, duration:2});
        photos.forEach(p => {
            gsap.to(p.position, {x:p.userData.treePos.x, y:p.userData.treePos.y, z:p.userData.treePos.z, duration:1.5});
            gsap.to(p.rotation, {x:p.userData.treeRot.x, y:p.userData.treeRot.y, z:p.userData.treeRot.z, duration:1.5});
        });
    }
    else if (gesture === 'OPEN' && STATE.current !== 'SCATTER') {
        STATE.current = 'SCATTER'; status.innerText = "SCATTER (FLOATING)"; exitFocus();
        gsap.to(treeSystem.material.uniforms.mixVal, {value:1, duration:2});
        photos.forEach(p => {
            gsap.to(p.position, {x:p.userData.scatterPos.x, y:p.userData.scatterPos.y, z:p.userData.scatterPos.z, duration:2});
            gsap.to(p.rotation, {x:p.userData.scatterRot.x, y:p.userData.scatterRot.y, z:p.userData.scatterRot.z, duration:2});
        });
    }
    else if (gesture === 'PINCH') {
        if (STATE.hoveredPhoto && STATE.current !== 'FOCUS') enterFocus(STATE.hoveredPhoto);
    }
}

function enterFocus(obj) {
    STATE.current = 'FOCUS'; STATE.focusedPhoto = obj; document.getElementById('state-text').innerText = "MEMORY (FOCUSED)";
    const target = new THREE.Vector3(0, 0, -15).applyMatrix4(camera.matrixWorld);
    gsap.to(obj.position, {x:target.x, y:target.y, z:target.z, duration:1, ease:"power2.out", onUpdate: () => obj.lookAt(camera.position)});
    gsap.to(obj.scale, {x:2.5, y:2.5, z:2.5, duration:1});
    gsap.to(obj.rotation, {z:0, duration:1});
}

function exitFocus() {
    if(STATE.focusedPhoto) {
        gsap.to(STATE.focusedPhoto.scale, {x:1, y:1, z:1, duration:0.5});
        STATE.focusedPhoto = null;
    }
}

function animate() {
    requestAnimationFrame(animate);
    const time = performance.now() * 0.001;

    smoothedMouse.lerp(rawMouse, CONFIG.cursorSmoothing);

    if (STATE.handDetected && cursorSprite) {
        cursorSprite.visible = true;
        raycaster.setFromCamera(smoothedMouse, camera);
        
        const defaultCursorPos = new THREE.Vector3(smoothedMouse.x, smoothedMouse.y, 0.5)
            .unproject(camera).normalize().multiplyScalar(30).add(camera.position);
        cursorSprite.position.copy(defaultCursorPos);
        cursorSprite.material.opacity = 0.5 + Math.sin(time * 10) * 0.3;

        if (STATE.current === 'SCATTER') {
            const intersects = raycaster.intersectObjects(scene.children, true);
            let found = null;
            for (let i = 0; i < intersects.length; i++) {
                if (intersects[i].object.parent && photos.includes(intersects[i].object.parent)) {
                    found = intersects[i].object.parent;
                    cursorSprite.position.copy(intersects[i].point); 
                    break;
                }
            }
            if (found !== STATE.hoveredPhoto) {
                if (STATE.hoveredPhoto) gsap.to(STATE.hoveredPhoto.scale, {x:1, y:1, z:1, duration:0.3});
                if (found) gsap.to(found.scale, {x:1.2, y:1.2, z:1.2, duration:0.3, ease:"back.out"});
                STATE.hoveredPhoto = found;
            }
        } else { STATE.hoveredPhoto = null; }
    }

    if(treeSystem) treeSystem.material.uniforms.time.value = time;
    if(snowSystem) {
        const snowPos = snowSystem.geometry.attributes.position.array;
        for(let i=1; i<snowPos.length; i+=3) {
            snowPos[i] -= 0.15;
            if(snowPos[i] < -60) snowPos[i] = 100;
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;
    }

    if (STATE.current !== 'FOCUS') {
        if(!STATE.handDetected && STATE.current === 'TREE') STATE.targetRotationY += 0.0015;
        scene.rotation.y += (STATE.targetRotationY - scene.rotation.y) * 0.05;
    }
    
    if(STATE.current === 'SCATTER') {
        photos.forEach((p,i) => {
            if(p !== STATE.focusedPhoto && p !== STATE.hoveredPhoto) {
                p.position.y += Math.sin(time + i)*0.015;
            }
        });
    }

    if(composer) composer.render();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

// ÂêØÂä®ÈÄªËæëÔºöÁ°Æ‰øù Three.js ÂàùÂßãÂåñÔºåÁÑ∂ÂêéÂ∞ùËØï MediaPipe
window.onload = function() {
    initThree();
    setupMediaPipe();
    
    // Ë∂ÖÊó∂‰øùÈô©ÔºöÂ¶ÇÊûú 6ÁßíÂêéËøòÂú®LoadingÔºåËØ¥ÊòéÊëÑÂÉèÂ§¥/Ê®°ÂûãÊåÇ‰∫ÜÔºåÂº∫Âà∂ËøõÂÖ•
    setTimeout(() => {
        const loader = document.getElementById('loader');
        if (loader.style.display !== 'none') {
            logError("Network/Camera timeout. Auto-starting scene...");
            hideLoader();
        }
    }, 6000);
};

</script>
</body>
</html>
